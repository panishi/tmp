# Item 24：ユニヴァーサル参照と右辺値参照の違い
## はじめに
人は真実により解放されると言うが，状況が適切ならば周到な嘘でもやはり解放されるものだ．
本項目はこの種の嘘だ．
しかしソフトウェアを扱う以上は「嘘」などという言葉は使わず，本項目は「抽象化」すると言おう．

ある型 `T` の右辺値参照を宣言するには，`T&&` と記述する．
このため「`T&&`」を見れば，これは右辺値参照だと受け取るのは当然に思える．
しかし，事はそう簡単ではない．
```cpp
void f(Widget&& param);          // 右辺値参照

Widget&& var1 = Widget();        // 右辺値参照

auto&& var2 = var1;              // 右辺値参照ではない

template<typename T>
void f(std::vector<T>&& param);  // 右辺値参照

template<typename T>
void f(T&& param);               // 右辺値参照ではない
```

## 「`T&&`」の2つの意味
1つはもちろん右辺値参照だ．
この参照は期待通り，バインドするのは右辺値のみで，その存在理由はムーブ元になれるオブジェクトの表現にある．

もう1つの意味は，右辺値参照か左辺値参照の **どちら** か一方を表すことだ．
ソースコード上では右辺値参照と見分けがつかない（どちらも「`T&&`」）が，あたかも左辺値参照（「`T&`」)であるかのように振る舞える．
この2つの性質を併せ持つため，左辺値にも右辺値にもバインド可能となっている．
さらに，`const` ・非 `const` オブジェクト，`volatile` ・非 `volatile` オブジェクトにも，`const` かつ `volatile` なオブジェクトにもバインド可能だ．
つまり，実質的にどんなものにもバインド可能となっている．
著者はこれを **ユニヴァーサル参照** (universal reference) と呼んでいる．

## ユニヴァーサル参照を使用する場面
主に2つある．

### 関数テンプレートの仮引数
```cpp
template<typename T>
void f(T&& param);   // param はユニヴァーサル参照
```

### `auto` による宣言
```cpp
auto&& var2 = var1;  // var2 はユニヴァーサル参照
```

## 型推論がない例
上記の使用に共通するのは型推論 (type deduction) だ．
1つ目の例では `f` は `param` の型を推論するし，2つ目の例では `var2` の型を推論する．
一方，次に挙げる例では型推論がない．
型推論を伴わない「`T&&`」は右辺値参照を表す．
```cpp
void f(Widget&& param);    // 型推論ではない，paramは右辺値参照

Widget&& var1 = Widget();  // 型推論ではない，var1は右辺値参照
```

## ユニヴァーサル参照と初期化
ユニヴァーサル参照は参照なため，初期化が必須だ．
ユニヴァーサル参照は，初期化子が右辺値ならば右辺値参照を，左辺値ならば左辺値参照を表す．
関数仮引数がユニヴァーサル参照の場合は，呼び出し時に渡したものが初期化子だ．
```cpp
template<typename T>
void f(T&& param);  // paramはユニヴァーサル参照

Widget w;
f(w);               // fには左辺値が渡される，paramの型はWidget&（左辺値参照）

f(std::move(w));    // fには右辺値が渡される，paramの型はWidget&&（右辺値参照）
```

## ユニヴァーサル参照の制限
参照がユニヴァーサル参照になるためには型推論が必須ですが，それだけではない．
参照を宣言する形式としても正当である必要があるが，この形式には制約が多く，厳密に「`T&&`」と記述しなければならない．
```cpp
template<typename T>
void f(std::vector<T>&& param);  // paramは右辺値参照
```

`f` を実行すると，型 `T` が推論される（呼び出し側が明示的に指定するような特殊な場合は除く）．
しかし，`param` の型を宣言する形式は「`T&&`」ではなく「`std::vector<T>&&`」なため，`param` はユニヴァーサル参照とはならず，右辺値参照となる．
`f` へ左辺値を渡そうとすると，コンパイラは喜々としてこれを指摘してくる．
```cpp
std::vector<int> v;
f(v);                     // エラー！ 左辺値を右辺値参照にバインドできない
```

`const` 修飾子を単に加えるだけでも，ユニヴァーサル参照にはなれない．
```cpp
template<typename T>
void f(const T&& param);  // paramは右辺値参照
```

## `push_back` の例
テンプレート内だからといっても，常に型が推論されるとは限らない．
`std::vector` のメンバ関数 `push_back` を例とする．
```cpp
template <class T, class Allocator = allocator<T>>  // C++ 標準より
class vector {
public:
    void push_back(T&& x);
    …
};
```

`push_back` の仮引数はまぎれもなくユニヴァーサル参照の形式だが，型推論を伴わない．
`push_back` はインスタンス化した特定の `vector` の一部であり，インスタンス化時の型が `push_back` の完全な宣言を決定する．
`Widget` の `std::vector` は次のようにインスタンス化される．
```cpp
class vector<Widget, allocator<Widget>> {
public:
    void push_back(Widget&& x);  // 右辺値参照
    …
};
```

`vector<T>` に対するこの `push_back` は（オーバロードされるため `void push_back(const T& x)` もある），常に `T` の右辺値参照型の仮引数を宣言する．

## `emplace_back` の例
対照的に，`std::vector` のメンバ関数 `emplace_back` は，概念的には同等でも型推論を伴う．
```cpp
template <class T, class Allocator = allocator<T>>  // 変わらずC++標準より
class vector {
public:
    template <class... Args>
    void emplace_back(Args&&... args);
    …
};
```

型仮引数 `Args` は `vector` の型仮引数 `T` に従属していないため，`emplace_back` を呼び出すたびに `Args` を推論しなければならない．

`emplace_back` の型仮引数は `Args` と名付けられているが，ユニヴァーサル参照であることは変わらない．
当然，型名は `T` である必要はない．
```cpp
template<typename MyTemplateType>  // paramはユニヴァーサル参照
void someFunc(MyTemplateType&& param);
```

## ラムダ式の例
`auto` で宣言した変数はユニヴァーサル参照にもなれると述べたが，より正確には，型を `auto&&` で宣言した変数は型が推論されかつ正しい形式（「`T&&`」）であるため，ユニヴァーサル参照になれる．
`auto` で宣言したユニヴァーサル参照は，関数テンプレートの仮引数に用いるユニヴァーサル参照ほど一般的ではないが，C++14では多く使用される．
C++14のラムダ式では仮引数をauto&&と宣言できるためだ．
例えば，ある関数の所要実行時間を測定するC++14のラムダ式は，次のように記述できる．
```cpp
auto timeFuncInvocation = [](auto&& func, auto&&... params)  // C++14
{
    // タイマ開始
    // paramsを与えfuncを実行
    std::forward<decltype(func)>(func)(
        std::forward<decltype(params)>(params)...
    );
    // タイマ停止，経過時間を記録
};
```

上例のラムダ式にある「`std::forward<decltype(blah blah blah)>`」は項目33で解説する．
重要な点はラムダ式が `auto&&` と宣言している仮引数だ．
`func` は任意の呼び出し可能オブジェクト，左辺値，または右辺値にバインドできるユニヴァーサル参照であり，`params` はゼロ個以上の任意の型，任意の個数のオブジェクトにバインドできるユニヴァーサル参照だ（すなわちユニヴァーサル参照のパラメータパック）．
結果，`auto` で宣言したユニヴァーサル参照のおかげで，`timeFuncInvocation` はほぼどんな関数の時間測定にも対応できる（「ほぼどんな関数」とした理由については項目30を参照）．

## おわりに
本項目，ユニヴァーサル参照の基礎は，全体を通じ ~~虚構~~，~~嘘~~，「抽象化」であることは忘れないでおこう．
根底にある真実は **参照の圧縮** (reference collapsing) というもので，項目28で別途解説する．
真実は別にあると言っても，この抽象化が無意味になる訳ではない．
右辺値参照とユニヴァーサル参照を区別できれば，ソースコードをより正確に理解でき，同僚との意思疎通でも曖昧さを排除できる．
また，右辺値参照とユニヴァーサル参照の差異を前提とした項目25，項目26にも納得がいくだろう．
ユニヴァーサル参照による抽象化も参照の圧縮を細部まで意識した作業より通常は望ましいものだ．

## Things to remember
- 関数テンプレートの仮引数の型が，推論した型 `T` に対する `T&&` の場合，または `auto&&` により宣言したオブジェクトの場合は，その仮引数やオブジェクトはユニヴァーサル参照である．
- 宣言した型の形式が厳密に `type&&` でない場合，または型の推論を伴わない場合は，`type&&` は右辺値参照を表す．
- 右辺値により初期化したユニヴァーサル参照は右辺値参照に対応する．
また，左辺値により初期化したユニヴァーサル参照は左辺値参照に対応する．
