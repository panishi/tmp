---
marp: true
transition: "slide"
slideNumber: true
---
<!-- theme: gaia -->
<!-- size: 16:9 -->
<!-- paginate: true -->

# Effective Modern C++
はじめに

2023/06/21

---
#### C++ の公式バージョン
- C++ の公式バージョンは4つある (C++98，C++03，C++11，C++14)．
- C++98 と C++03 の差異は大きくないため，本書ではこの2つを C++98 と総称する．
- 本書で C++11 と表記した場合は，C++11 と C++14 の両方を指す．
- 本書が C++14 と表記した場合は，C++14 に特有の事柄について述べる．
- C++ とだけ表記した場合は，全バージョンに通用する内容を表す．

---
#### ムーブセマンティクス (1)
- ムーブセマンティクスは右辺値 (rvalue) 式と左辺値 (lvalue) 式を区別する．
- 右辺値とはオブジェクトがムーブ演算可能なことを示し，左辺値は一般にそうではない．
- 右辺値は関数が返す一時オブジェクトに対応し，左辺値は名前・ポインタ・左辺値参照から辿れるオブジェクトに対応する．

---
#### ムーブセマンティクス (2)
- 式が左辺値か否かを判断するには，そのアドレスを得られるかを確認すれば良いことが経験的に知られている．
- アドレスを得られば左辺値，得られなければ通常は右辺値．
- この経験則によると，式が左辺値か右辺値ということと，式の型は別だと覚えておける利点がある．
```cpp
class Widget {
public:
    Widget(Widget&& rhs);  // rhs は右辺値参照型だが左辺値である
    …
}; 
```

---
#### ムーブとコピー (1)
- C++ にはコピーコンストラクトしたコピーとムーブコンストラクトしたコピーを区別する用語がない．
```cpp
void someFunc(Widget w);   // someFunc の仮引数 w は値渡しされる

Widget wid;                // wid は何らかの Widget
someFunc(wid);             // w は wid をコピーコンストラクトしたコピー
someFunc(std::move(wid));  // w は wid をムーブコンストラクトしたコピー
```

---
#### ムーブとコピー (2)
- 一般に，左辺値のコピーはコピーコンストラクトされ，右辺値のコピーはムーブコンストラクトされる．
- オブジェクトが他のオブジェクトのコピーであることしか分からなければ，そのコピーを作成したコストが高いか安いかは分からないということを意味する．
- `someFunc` に渡されたものが右辺値か左辺値かが分からなければ，仮引数 `w` の作成コストが高いか安いかを知る術はないということ．

---
#### 実引数と仮引数
- 関数呼び出しにおいて，呼び出し側に記述した式は関数の実引数 (argument) と呼ばれ，実引数が関数の仮引数 (parameter) を初期化する．
- 仮引数は左辺値だが，実引数はその初期化処理により左辺値にも右辺値にもなり得る．
- この点は完全転送 (perfect forwarding) に大きく影響する．

---
#### 例外安全性
- 充分に設計された関数は例外安全 (exception safe) である．
- 最低でも basic 例外安全性 (basic exception safety，basic guarantee，basic 保証，基本保証) を保証している．
- strong 例外安全性 (strong exception safety，strong guarantee，strong 保証，強い保証) を保証した関数では，例外が発生しても呼び出し側でプログラムの状態は呼び出し前から変化しない．

---
#### 関数オブジェクト
- 本書が関数オブジェクト (function object) と表記した場合，通常はメンバ関数 `operator()` を実装したオブジェクトを意味する．
- この用語はやや広い意味で用いることもあり，`operator()` を実装したオブジェクトだけではなく，通常関数や C ライクの関数ポインタも含む．
- さらに一般化し，メンバ関数ポインタも含めた場合は呼び出し可能オブジェクト (callable object，コール可能オブジェクト) と表現する．

---
#### 用語の区別
- ラムダ式から作成した関数オブジェクトを指し，クロージャ (closure) と言う．
- ラムダ式とそこから作成されたクロージャを区別する必要がある場面はごく限られるため，本書ではこの2つを総称しラムダ (lambdas) と表記する．
- 関数テンプレート (function template，関数を生成するテンプレート) と，テンプレート関数 (template function，テンプレートから生成された関数) も基本的に区別しない．
- クラステンプレート (class template) とテンプレートクラス (template class) も同様．

---
#### 宣言と定義 (1)
- 宣言 (declaration) では，どのメモリに配置するか，どのように実装するかなど，その詳細を明示しないまま名前や型を導入する．
```cpp
extern int x;                // オブジェクトの宣言

class Widget;                // クラスの宣言

bool func(const Widget& w);  // 関数の宣言

enum class Color;            // スコープを持つ enum の宣言
```

---
#### 宣言と定義 (2)
- 定義 (definition) では， メモリ上の配置や実装詳細を明示する．
```cpp
int x;                      // オブジェクトの定義

class Widget {              // クラスの定義
    …
};

bool func(const Widget& w)  // 関数の定義
{ return w.size() < 10; } 

enum class Color            // スコープを持つ enum の定義
{ Yellow, Red, Blue };
```

---
#### シグネチャ
- 著者は関数のシグネチャ (signature) を，仮引数および戻り型を指定する宣言の一部と定義し，関数名と仮引数名は含まない．
- 仮引数と戻り型以外の関数宣言の要素は除外する (`noexcept` や `constexpr` などが記述されていても除外する)．
-「シグネチャ」の公式な定義は著者の定義とは一致しない (公式な定義では戻り型を含まない場合がある)．

---
#### 非推奨
- 時として C++ 標準化委員会がそれまでの機能を非推奨 (deprecate) とすることがある．
- このような機能は標準仕様内での位置付けが変更され，将来のバージョンで削除される可能性がある．
- コンパイラが警告しない場合もあるが，使用は最大限避けるべき．

---
#### 未定義動作
- 標準仕様が演算の実行結果を指し，未定義動作 (undefined behavior) であると表現することがある．
- これは，実行時動作が予測不可能になることを意味する．
- `[]` による `std::vector` の範囲外のインデックス演算，未初期化イテレータの参照外し演算，データ競合などが挙げられる．

---
#### その他
- 本書では，組み込みポインタや `new` が返したポインタを総称して，raw ポインタ (raw pointer) と言う．
- raw ポインタの反対語はスマートポインタ (smart pointer) だ．
- ソースコード内のコメントでは，コンストラクタ (constructor) を ctor，デストラクタ (destructor) を dtor と短縮して表記することがある．
