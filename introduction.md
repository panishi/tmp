# はじめに（用語と表記）
## C++のバージョンについて
C++の公式バージョンは本書執筆時点で4つあり，それぞれの名前にはISO標準に採用された年が付けられている．
C++98，C++03，C++11，C++14だ．
- C++98とC++03の差異は大きくないため，本書ではこの2つをC++98と総称する．
- 本書でC++11と表記した場合は，C++11とC++14の両方を指す．
- 本書がC++14と表記した場合は，C++14に特有の事柄について述べる．
- 単純にC++とだけ表記した場合は，全バージョンに通用する内容を表す．

その結果，次のような表現になる．
- C++では高い効率性を実現できる（すべてのバージョンで真）
- C++98は並行性に未対応である（C++98とC++03についてのみ真）
- C++11ではラムダ式を使用できる（C++11とC++14では真）
- C++14は一般化した関数戻り型推論機能を備えている（C++14についてのみ真）

## 右辺値と左辺値
ムーブセマンティクスは **右辺値** (rvalue) 式と **左辺値** (lvalue) 式を区別するものだ．
右辺値とはオブジェクトがムーブ演算可能なことを示し，左辺値は一般にそうではない．
基本的には（常にそうだとは限らない），右辺値は関数が返す一時オブジェクトに対応し，左辺値は名前，ポインタ，左辺値参照から辿れるオブジェクトに対応する．

式が左辺値か否かを判断するには，そのアドレスを得られるかを確認すれば良いことが経験的に知られている．
アドレスを得らればまず左辺値であり，得られなければ通常は右辺値だ．
この経験則の良いところは，式が左辺値か右辺値ということと，式の型は別だと覚えておける（型 `T` に対して，`T` 型の左辺値も `T` 型の右辺値もあり得る）．
仮引数自体は左辺値なので，右辺値参照型の仮引数を扱う場合に特に重要となる．
```cpp
class Widget
{
public:
    Widget(Widget&& rhs);  // rhsは右辺値参照型だが左辺値である
    …
};
```

上例の `Widget` のムーブコンストラクタ内で `rhs` のアドレスを得ても，まったく問題ない．
型は右辺値参照でも `rhs` は左辺値であるためだ（すべての仮引数は左辺値）．

## 疑似コードの表記法
- クラス名を `Widget` としている．
クラスの特殊な部分を述べる場合を除き，`Widget` の宣言は省略する．
- 仮引数名を `rhs` (right-hand side) としている．
**ムーブ演算**（move operation，ムーブコンストラクタとムーブ代入演算子），および **コピー演算**（copy operation，コピーコンストラクタとコピー代入演算子）で著者が好んで使用する仮引数名だ．
二項演算子の右辺仮引数にも使用する．
`lhs` は「left-hand side」を略したものである．
```cpp
Matrix operator+(const Matrix& lhs, const Matrix& rhs);
```

- 「他のコードをここに挿入可能」ということを表現する場合は、「…」と表記する．
この間隔が狭い三点は，間隔が広い三点省略記号（「...」）とは意味が異なる．
後者はC++11の可変長テンプレートのソースコードで使用する．
```cpp
template <typename... Ts>
void processVals(const Ts&... params)  // この2つはC++の省略記号
{
    …  // これは「何かコードが入る」意味
}
```

テンプレートの型仮引数の宣言に `typename` と記述しているが，これは単なる好みである．
`class` と記述してもまったく問題なく動作する．
C++言語標準から引用したコードでは，言語標準そのままに型仮引数を `class` で宣言する．

## コピーについて
オブジェクトを同じ型の別オブジェクトにより初期化する場合，ムーブコンストラクタが動作する場合でも，新オブジェクトを旧オブジェクトのコピーと表現する．
残念なことに，C++にはコピーコンストラクトしたコピーとムーブコンストラクトしたコピーを区別する用語がない．
```cpp
void someFunc(Widget w);  // someFuncの仮引数wは値渡しされる

Widget wid;     // widは何らかのWidget
someFunc(wid);  // このsomeFunc呼び出しで，wはwidをコピーコンストラクトしたコピー

someFunc(std::move(wid));  // このsomeFunc呼び出しで，wはwidをムーブコンストラクトしたコピー
```

左辺値のコピーは通常コピーコンストラクトされ，右辺値のコピーは一般にムーブコンストラクトされる．
オブジェクトが他のオブジェクトのコピーであるということしか分からなければ，そのコピーを作成したコストが高いか安いかは分からない．
上例のコードでは，`someFunc` に渡されたものが右辺値か左辺値かが分からなければ，仮引数 `w` の作成コストが高いか安いかを知る術がないということだ．

## 引数について
- 実引数 (argument)：関数呼び出しにおいて，呼び出し側に記述した式
- 仮引数 (parameter)：実引数によって初期化される

実引数と仮引数の区別は重要．
仮引数は左辺値だが，実引数はその初期化処理により左辺値にも右辺値にもなり得る．
この点は **完全転送** (perfect forwarding) の動作に大きく影響する．
完全転送とは，ある関数が受け取った実引数を，元の実引数の右辺値性，左辺値性を維持したまま別関数へ渡す動作を指す．
詳細はItem30で述べる．

## 例外安全性について
十分に設計された関数は **例外安全** (exception safe) だ．
- 基本的例外安全性（basic exception safety，basic guarantee，基本保証）：例外が発生しても呼び出し側でプログラムの不変条件は維持され，リソースの解放もれも発生しないことが保証される．
- 強い例外安全性（strong exception safety，strong guarantee，強い保証）：例外が発生しても，呼び出し側でプログラムの状態は呼び出し前から変化しない．

## 関数オブジェクトについて
本書で **関数オブジェクト** (function object) と表記した場合，通常はメンバ関数 `operator()` を実装したオブジェクトを指す．
この用語はやや広い意味で用いることもあり，非メンバ関数の形式で呼び出し可能なものすべて（通常関数やCライクの関数ポインタなど）を指す場合もある．
さらに一般化し，メンバ関数ポインタも含めた場合は **呼び出し可能オブジェクト**（callable object，コール可能オブジェクト）と表記する．
通常は定義の細かな区別を意識する必要はなく，これらはC++の何らかの関数呼び出し構文を用い実行できるものと考えればよい．

## ラムダについて
ラムダ式から作成した関数オブジェクトを，**クロージャ** (closure) と言う．
ラムダ式とそこから作成されたクロージャを区別する必要がある場面はごく限られるため，本書ではこの2つを総称して **ラムダ** (lambdas) と表記する．
**関数テンプレート**（function template，関数を生成するテンプレート）と，**テンプレート関数**（template function，テンプレートから生成された関数）も基本的に区別しないし，**クラステンプレート** (class template) と **テンプレートクラス** (template class) も同様．

## 宣言と定義
**宣言** (declaration) とは，どのメモリに配置するか，どのように実装するかなど，その詳細を明示しないまま名前や型を導入するものだ．
```cpp
extern int x;  // オブジェクトの宣言

class Widget;  // クラスの宣言

bool func(const Widget& w);  // 関数の宣言

enum class Color;  // スコープを持つenumの宣言（Item10を参照）
```

**定義** (definition) とは，メモリ上の配置や実装詳細を明示するものだ．
```cpp
int x;  // オブジェクトの定義

class Widget  // クラスの定義
{
    …
};

bool func(const Widget& w)  // 関数の定義
{
    return w.size() < 10;
}

enum class Color  // スコープを持つenumの定義
{
    Yellow, Red, Blue
};
```

「定義」は「宣言」を包含するため，定義だけを特に明示する必要がない限りは，宣言と表記する．

## シグネチャについて
著者は関数の **シグネチャ** (signature) を，仮引数および戻り型を指定する宣言の一部と定義している．
これには関数名と仮引数名は含まれない．
仮引数と戻り型以外の関数宣言の要素は除外する（`noexcept` や `constexpr` など，Item14，Item15を参照）．
「シグネチャ」の公式な定義は著者の定義とは一致しないが，本書においては著者の定義の方が実用的だ（公式な定義では戻り型を含まない場合がある）．

## 非推奨
C++は通常は後方互換的だ．
しかし時として標準化委員会がそれまでの機能を **非推奨** (deprecate) とすることもある．
このような機能は，将来のバージョンで削除される可能性がある．
コンパイラが警告しない場合もあるが，使用は最大限避けるべき．

## 未定義動作
標準仕様が演算の実行結果を指し，**未定義動作** (undefined behavior, UB) であると表現することがある．
未定義動作には，角括弧（「`[]`」）による `std::vector` の範囲外のインデックス演算，未初期化イテレータの参照外し演算，データ競合などがある．

## rawポインタ
本書では，組み込みポインタや `new` が返したポインタを総称し，**rawポインタ** (raw pointer) と言う．
rawポインタの反対語は **スマートポインタ** (smart pointer) だ．
スマートポインタは，`std::weak_ptr` を除き（Item20を参照），参照外し演算子（`operator->` と `operator*`）をオーバロードするのが通例だ．

## *ctor* と *dtor*
ソースコード内のコメントでは，「コンストラクタ (constructor)」を *ctor* と，「デストラクタ (destructor)」を *dtor* と短縮して表記することがある．
