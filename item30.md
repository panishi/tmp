# Item 30：完全転送できない場面を把握する
## はじめに
ある関数 `f` があり，`f` に転送する関数（テンプレート）を開発しよう．
```cpp
template<typename T>
void fwd(T&& param)             // どんな実引数でも受け取る
{
    f(std::forward<T>(param));  // fへ転送
}
```

上例のテンプレート `fwd` は任意の型の実引数をとり，どんなものでも転送する．
この汎用性を論理的に拡張すれば，転送関数は単なるテンプレートではなく可変長 (variadic) テンプレートとし，個数も任意な実引数を受け取るべきだ．
```cpp
template<typename... Ts>
void fwd(Ts&&... params)             // 任意の実引数をとる
{
    f(std::forward<Ts>(params)...);  // fへ転送
}
```

上例は標準コンテナの直接配置 (emplacement) 関数でも採用している形態だ（Item 42を参照）．
他にもスマートポインタfactory関数の `std::make_shared`，`std::make_unique` がある（Item 21を参照）．

上例の目的関数 `f` と転送関数 `fwd` では，同じ実引数に対する両者の動作が異なると，完全転送できない．
```cpp
f(expression);    // fとfwdの処理が異なる場合
fwd(expression);  // fwdはfにexpressionを完全には転送できない
```

この問題を起こす実引数は何種類かあり，その種類と回避策の把握は重要だ．
完全転送できない種類の実引数を1つずつ見て行く．

## 波括弧による初期化子
`f` を次のように宣言したとする．
```cpp
void f(const std::vector<int>& v);
```

`f` に波括弧による初期化子を与えればコンパイルできる．
```cpp
f({ 1, 2, 3 });  // よろしい，{ 1, 2, 3 }は暗黙にstd::vector<int>へ変換される
```

しかし，同じ波括弧による初期化子を `fwd` へ与えるとコンパイルできない．
これは，波括弧による初期化子の使用が完全転送できない種類に該当するため．
```cpp
fwd({ 1, 2, 3 });  // エラー！コンパイルできない
```

この種の完全転送できない原因はすべて同じだ．
`f` の直接呼び出しでは，コンパイラは呼び出し時点で渡された実引数と `f` が宣言した仮引数の型を比較し，その互換性を確認する．
この時点で必要に応じ，呼び出し可能となるように暗黙の変換も実行する．

`f` を転送関数テンプレート `fwd` から間接的に呼び出した場合，コンパイラは `fwd` 呼び出し時点で渡された実引数と `f` が宣言した仮引数を比較しない．
代わりに，`fwd` に渡された実引数の型を推論し，この推論した型を `f` の仮引数宣言の型と比較する．
次の2つのうちの1つでも発生すると，完全転送できない．
- コンパイラが `fwd` の仮引数の型を1つでも推論できない．  
コンパイルできない．
- コンパイラが `fwd` の仮引数に1つでも「誤った」型を推論する．  
「誤った」とは，推論した型でインスタンス化した `fwd` をコンパイルすらできない場合だ．
また，`fwd` の推論した型を用いて呼び出した `f` の動作が，`fwd` に渡した実引数を直接 `f` に与え呼び出した場合の動作と異なる場合もある．
この動作の不一致の原因の1つには，`f` がオーバロードされた関数名であり，「正しくない」型が推論されたため，`fwd` が呼び出す `f` が，`f` を直接呼び出した場合とは異なるオーバロードに解決されたことが考えられる．

上例の「`fwd({ 1, 2, 3 })`」呼び出しでは，関数テンプレートの `std::initializer_list` と宣言されていない仮引数に，波括弧による初期化子を渡している点が問題だ．
標準仕様ではこれを「推論対象外コンテクスト (non-deduced context)」と定義している．
`fwd` の仮引数が `std::initializer_list` と宣言されていないため，コンパイラが `fwd` 呼び出しにある`{ 1, 2, 3 }` という式の型を推論することを禁止するという意味だ．
`fwd` の仮引数の型推論が禁止されるため，コンパイラが拒否するのも当然だ．

Item 2では，波括弧による初期化子で初期化し `auto` で宣言した変数の型推論は成功すると述べた．
つまり，転送関数が推論すべき型が `std::initializer_list` の場合は，`auto` でローカル変数を宣言し，このローカル変数を転送関数に与えればよい．
```cpp
auto il = { 1, 2, 3 };  // ilの型はstd::initializer_list<int>と推論
fwd(il);                // よろしい，ilをfへ完全転送
```

## ヌルポインタとしての `0` や `NULL`
Item 8 では，テンプレートにヌルポインタとして `0` や `NULL` を渡そうとすると，型推論が正しく解釈できず，渡した実引数をポインタ型ではなく汎整数型（通常は `int`）と推論すると述べた．
その結果，`0` も `NULL` もヌルポインタとしては完全転送できない．
修正は容易で，`nullptr` を渡せば良い（Item 8を参照）．

## 宣言のみの `static const` な汎整数メンバ変数
クラスに `static const` な汎整数のメンバ変数を定義する必要はなく，宣言のみで十分だ．
これはコンパイラがメンバ変数の値を **定数伝播** (const propagation) するためで，メモリを割り当てる必要がない．
```cpp
class Widget {
public:
    static const std::size_t MinVals = 28;  // MinValsの宣言
    …
};
…  // MinValsの定義はない
std::vector<int> widgetData;
widgetData.reserve(Widget::MinVals);  // MinValsの使用
```

定義がなくとも，コンパイラが `MinVals` の使用箇所すべてで `28` という値をポチャンと落としてくれる（コンパイラの要件）．
`MinVals` にはメモリ領域が割り当てられておらず，値は問題にはならない．
`MinVals` のアドレスが必要な場合，`MinVals` にはメモリ領域が必要になり，`MinVals` の定義を追加しない限り，コンパイルは可能でもリンカエラーとなる．

このことを頭に入れて置き，次のような関数 `f` を宣言したとする．
```cpp
void f(std::size_t val);
```

`f` に `MinVals` を渡しても，コンパイラが `MinVals` を単純にその値に置き換えるため問題はない．
```cpp
f(Widget::MinVals);  // 問題なし，「f(28)」として処理される
```

しかし，`fwd` 経由で `f` を呼び出そうとすると，そうは簡単には行かない．
```cpp
fwd(Widget::MinVals);  // リンカエラー！
```

ソースコード上では `MinVals` のアドレスは使用していないが，`fwd` の仮引数はユニヴァーサル参照だ．
また，バイナリコードとなったプログラム（およびハードウェア上）では，ポインタと参照は本質的に同じものだ．
`MinVals` を参照渡しするとポインタを渡したことと同じ意味になり，ポインタが指す何らかのメモリ領域が存在しなければならない．
この制約が原因で，完全転送を用いなければエラーにならない場面で完全転送がエラーとなる．

しかし，すべての処理系にこの制約がある訳ではない．
コンパイラ・リンカによっては，定義していない `static const` な汎整数メンバ変数でも完全転送可能なことがある．
そのようなコードの可搬性は期待できないので，可搬性を確保するには，`static const` な汎整数メンバ変数を定義するしかない．
```cpp
const std::size_t Widget::MinVals;  // Widgetの.cppファイル内
```

改めて初期化子を記述していない点に注意しよう．
この詳細を気にすること必要はない．

また，本節の内容は，宣言のみのスタティックな汎整数 `constexpr` メンバ変数（`constexpr` メンバ変数と `const` メンバ変数）にも適用される．

## オーバロードした関数名とテンプレート名
何らかの処理を実行する関数を渡し，関数 `f` の動作をカスタマイズできるとしよう．
渡す関数は `int` を受け取り，`int` を返すとすると，`f` は次のように宣言できる．
```cpp
void f(int (*pf)(int)); // pf = 「処理関数 (processing function)」

void f(int pf(int));  // 上例と同じfの宣言
```

どちらの形態をとるにせよ，次のオーバロード関数 `processVal` があるとする．
```cpp
int processVal(int value);
int processVal(int value, int priority);
```

`f` には `processVal` を渡せる．
```cpp
f(processVal);  // よろしい
```

これは，渡せること自体ある意味驚きだ．
`f` はその実引数に関数を指すポインタを要求しているが，`processVal` は関数ポインタでも関数でもなく，2つの異なる関数の名前だ．
一方で，コンパイラはどちらの `processVal` を使用するかを分かっている．
コンパイラは `int` を1つとる `processVal` を選択し，そのアドレスを `f` に渡す．

しかし，関数テンプレートである `fwd` には，要求する型に関する情報は一切ない．
そのため，コンパイラはどちらのオーバロードを渡すべきかを判断できない．
`processVal` そのものに型はなく，型がなければ推論はできない．
```cpp
fwd(processVal);  // エラー！どちらのprocessValか？
```

オーバロードした関数名ではなく（またはオーバロードした関数名に加え），関数テンプレートを使用しようとした場合にも同じ問題が発生する．
関数テンプレートは1つの関数を表現するものではなく，複数の関数を表現するものだ．
```cpp
template<typename T>
T workOnVal(T param)  // 値を処理するテンプレート
{ … }

fwd(workOnVal);  // エラー！どのworkOnValをインスタンス化するのか？
```

`fwd` のような完全転送する関数がオーバロード関数名やテンプレート名を受け取れるようにする方法は，転送させたいオーバロードやインスタンス化を手動で明示することだ．
例えば，`f` の仮引数と同じ型の関数ポインタを作成し，`processVal` や `workOnVal` で初期化（`processVal` の適切なバージョンが選択されるか，`workOnVal` が適切にインスタンス化される），これを `fwd` に渡せばよい．
```cpp
using ProcessFuncType = int (*)(int);  // typedefの作成，Item 9を参照

ProcessFuncType processValPtr = processVal;  // processValに必要なシグネチャを指定

fwd(processValPtr);  // よろしい
fwd(static_cast<ProcessFuncType>(workOnVal));  // これもよし
```

もちろん，`fwd` が転送する関数ポインタの型を把握しておかなければならない．
完全転送する関数とはどんなものでも受け取るよう設計されているので，何を渡すのかが明文化されていなければ分かりようがないということだ．

## ビットフィールド
関数の実引数にビットフィールドを用いた場合も完全転送できない．
IPv4ヘッダを次のようにモデル化してみよう．
```cpp
struct IPv4Header {
    std::uint32_t version:4,
                  IHL:4,
                  DSCP:6,
                  ECN:2,
                  totalLength:16;
    …
};
```

関数 `f` を仮引数に `std::size_t` をとるよう宣言したとする．
`IPv4Header` オブジェクトの `totalLength` フィールドを与えても問題なくコンパイルできる．
```cpp
void f(std::size_t sz);  // 呼び出す関数

IPv4Header h;
…
f(h.totalLength);  // よろしい
```

しかし，`fwd` を介して `h.totalLength` を `f` に転送しようとすると話は別．
```cpp
fwd(h.totalLength);  // エラー！
```

問題は，`fwd` の仮引数が参照であるのに対して `h.totalLength` は非 `const` なビットフィールドである点だ．
C++標準ではいつになく明確な文言でこの組み合わせを叱責している．
「非 `const` 参照にビットフィールドをバインドさせてはならない」と禁止するには理由がある．
ビットフィールドはマシンワードの任意の一部分（32ビット `int` の3-5ビットなど）だが，一部分だけを直接指し示す方法はない．
任意のビット群を指すポインタを作成する方法も（C++では，ポインタが指せる最小単位は `char` であると明記している），参照を任意のビット群にバインドさせる方法も存在しない．

実引数にビットフィールドをとる関数はすべてビットフィールドの値のコピーを受け取ると理解すれば，ビットフィールドの完全転送問題も容易に回避できえう．
ビットフィールドを渡せるのは値渡しの仮引数と，`const` 参照だ．
- 値渡しの仮引数では，呼び出された関数がビットフィールドの値のコピーを受け取る．
- `const` 参照仮引数の場合は，`int` など標準汎整数型のオブジェクトが保持するビットフィールド値のコピーがバインドされる．
`const` 参照をビットフィールドにバインドするのではなく，ビットフィールドの値をコピーした「通常」のオブジェクトにバインドされることになる．

完全転送関数へビットフィールドを渡す際に重要となるのは，転送先関数が受け取るのは常にビットフィールドの値のコピーとなる点だ．
明示的にコピーを作成し，コピーを与えて転送関数を呼び出せばよい．
```cpp
// ビットフィールの値をコピー，初期化の形式についてはItem 6を参照
auto length = static_cast<std::uint16_t>(h.totalLength);
fwd(length);  // コピーを転送
```

## おわりに
完全転送は，ほとんどの場合では宣伝文句通りに動作し，注意しなければならない場合は僅かだ．
しかし，完全転送が問題となる場面（一見問題なく見えるコードがコンパイルできない，コンパイルはできても期待とは違う動作となる場面）では，完全転送の完全ではない点の把握が重要となる．
その回避策も把握する必要があるが，ほとんどの場合は直観的で分かりやすいものだ．

## Things to remember
- テンプレートの型推論がエラーになった場合，または誤った型を推論した場合，完全転送はエラーとなる．
- 完全転送のエラー原因となる実引数には，波括弧による初期化子，ヌルポインタとして用いた `0` や `NULL`，宣言のみの `const static` な汎整数メンバ変数，テンプレート名，オーバロード関数名，ビットフィールドがある．
