---
marp: true
theme: "night"
transition: "slide"
slideNumber: true
title: "Chapter02"
---
<!-- theme: gaia -->
<!-- size: 16:9 -->
<!-- page_number: true -->
<!-- paginate: true -->

# プログラミングRust
5.3　共有と変更

2020/09/xx

---
## 5.3　共有と変更
- Rustでもダングリングポインタができてしまう場合がある
- 図5-7を参照
```rust
let v = vec![4, 8, 19, 27, 34, 10];
let r = &v;
let aside = v;  // ベクタをasideに移動
r[0];           // ダメ：未初期化状態になった`v`を使用
```

---
#### Rustは当然このエラーを検知する
- `r` の生存期間中，`v` はスコープにとどまっているにも関わらず，`v` の値が移動したため，`r` がまだ参照しているのに `v` が未初期化状態になってしまう
```
error[E0505]: cannot move out of `v` because it is borrowed
  --> references_sharing_vs_mutation_1.rs:10:9
   |
9  |     let r = &v;
   |              - borrow of `v` occurs here
10 |     let aside = v; // move vector to aside
   |         ^^^^^ move out of `v` occurs here
```

---
#### コンパイル可能となるための対処法
- `r` が先にスコープから外れ，参照の生存期間が `v` の `aside` への移動よ
りも先に終了するようにすれば，問題はない
```rust
let v = vec![4, 8, 19, 27, 34, 10];
{
    let r = &v;
    r[0];  // ok: ベクタはまだそこにある
}
let aside = v;
```

---
#### 大惨事は他にも…1
- ベクタをスライスの要素を使って拡張する便利な関数を考えてみる
```rust
fn extend(vec: &mut Vec<f64>, slice: &[f64]) {
    for elt in slice {
        vec.push(*elt);
    }
}
```
- 標準ライブラリでベクタに対して用意されている `extend_from_slice` メソッドの，柔軟でない（そしてまったく最適化されていない）バージョンとなっている

---
#### 大惨事は他にも…2
- 他のベクタや配列のスライスからベクタを作り上げることができる
```rust
let mut wave = Vec::new();
let head = vec![0.0, 1.0];
let tail = [0.0, -1.0];

extend(&mut wave, &head);  // waveを他のベクタで拡張
extend(&mut wave, &tail);  // waveを配列で拡張

assert_eq!(wave, vec![0.0, 1.0, 0.0, -1.0]);
```

---
#### 大惨事は他にも…3
- 他のベクタや配列のスライスからベクタを作り上げることができる
- 以下では，サインカーブの1周期分を作成
```rust
let mut wave = Vec::new();
let head = vec![0.0, 1.0];
let tail = [0.0, -1.0];

extend(&mut wave, &head);  // waveを他のベクタで拡張
extend(&mut wave, &tail);  // waveを配列で拡張

assert_eq!(wave, vec![0.0, 1.0, 0.0, -1.0]);
```

---
#### 大惨事は他にも…4
- 次の周期を追加するために，このベクタに自分自身を追加できるだろうか？
```rust
extend(&mut wave, &wave);
assert_eq!(wave, vec![0.0, 1.0, 0.0, -1.0,
                    　0.0, 1.0, 0.0, -1.0]);
```
- 一見すると良さそうだが，これはまずい
- `extend` の引数 `vec` は，呼び出し元が所有する `wave` を借用
- バッファの再確保により，`slice` が既にドロップされた古い要素のバッファを指し続けていることがある

---
#### これはRust固有の問題ではない
- コレクションを，参照しつつ同時に変更することは，多くの言語で難しい領域
- C++の `std::vector` の仕様では，「`vector` のバッファの再確保によってすべての参照，ポインタ，要素列を参照するイテレータが無効になる」
- Javaでは，`java.util.Hashtable` の変更については「イテレータを作った後で，イテレータ自身の `remove` メソッド以外で `Hashtable` の構造が変更されると，`ConcurrentModificationException` を返す」

---
#### Rustではコンパイル時に問題が分かる1
- このようなバグは，いつも発生するとは限らないため厄介
- Rustは，コンパイル時に `extend` の呼び出しに問題があると報告してくれる
```
error[E0502]: cannot borrow `wave` as immutable because it is also borrowed as mutable
 --> references_sharing_vs_mutation_2.rs:9:24
  |
9 | extend(&mut wave, &wave);
  |             ----   ^^^^- mutable borrow ends here
  |             |      |
  |             |      immutable borrow occurs here
  |             mutable borrow occurs here
```

---
#### Rustではコンパイル時に問題が分かる2
- ベクタに対する可変参照を借用することもできるし，その要素に対する共有参照を借用することもできるが，これらの参照の生存期間は重なっていてはいけないということ
- 双方の参照の生存期間が関数 `extend` の呼び出しを包含しているので，Rustはこのコー
ドを拒絶する

---
#### Rustの可変参照と共有参照のルール1
- 共有アクセスは読み出しのみのアクセスになる
    - 共有参照が借用した値は読み出すことしかできない
    - 共有参照の生存期間の間，参照先だけでなく参照先から辿ることのできるものはすべて，どのような方法でも変更することはできない
    - その構造体内の何であれ，可変参照で参照することはできない
    - 所有者が読み出ししかできない状態になっているため，共有参照で参照されているものは完全に凍結される

---
#### Rustの可変参照と共有参照のルール2
- 可変アクセスは排他アクセスになる
    - 可変参照で借用された値はその参照を通じてのみアクセスすることができる
    - 可変参照の生存期間の間，参照先および参照先から辿ることのできるものはすべて，他のパスから参照することはできない
    - 可変参照の生存期間と重なっていてよいのは，その可変参照から借用した参照だけ

---
#### `extend` 再考
- `extend` のバグは，2番目のルールに違反している
    - `wave` への可変参照を借用しているので，その可変参照がベクタやその要素に到達できる唯一の方法
    - スライスの共有参照は，要素に到達する別の方法そのものなので，2番目のルールに違反
- このバグを1つ目のルールの違反としても考えられる
    - `wave` の要素への共有変数を借用しているため，要素や `Vec` そのものはすべて読み出しのみ可能な状態になっている
    - 読み出しのみ可能な値に対して，可変参照を借用することはできない

---
#### 参照の借用と所有権ツリー
- どちらの種類の参照も，参照先への所有の経路上にある値と，参照先から到達できる値に対し
て何ができるかを規定する（図5-9）
- 参照先への所有の経路上にある値は，参照の生存期間中は変更できない
- 共有参照：経路上にある値は読み出しのみ可能
- 可変参照：完全にアクセスできなくなるため，参照が無効になるようなプログラムを書くことはできない

---
#### 共有参照，可変参照の例
```rust
let mut x = 10;
let r1 = &x;
let r2 = &x;      // ok: 複数の共有参照は可能
x += 10;          // エラー: `x`は借用されているので，代入することはできない

let m = &mut x;   // エラー: `x`を可変参照として借用することはできない
                  // 変更不能な共有参照として既に借用されているので

let mut y = 20;
let m1 = &mut y;
let m2 = &mut y;  // エラー: 可変参照は1度しか借用できない
let z = y;        // エラー: `y`は可変で借用されているので，使えない
```

---
#### 共有参照の例
- 共有参照からは，共有参照を再借用することができる
```rust
let mut w = (107, 109);
let r = &w;
let r0 = &r.0;      // ok: 共有参照を共有参照として再借用
let m1 = &mut r.1;  //エラー: 共有参照を可変参照として再借用することはできない
```

---
#### 可変参照の例
- 可変参照からは，再借用することはできない
```rust
let mut v = (136, 139);
let m = &mut v;
let m0 = &mut m.0;  // ok: 可変参照から可変参照を再借用
*m0 = 137;

let r1 = &m.1;      // ok: 可変参照から共有参照を再借用，m0と重なっていないのでOK
v.1;                // エラー: 別のパスからのアクセスは禁止されている
```

---
#### Rustの制約は厳格
- もともと実行したかった `extend(&mut wave, &wave)` に立ち戻ると，このコード修正する簡単な方法はない
- Rustはこのルールをあらゆる場所に適用
- 例えば，`HashMap` 中のある鍵への共有参照を借用したら，その共有参照の生存期間が終わるまで，`HashMap` の更新可能参照を借用することはできない

---
#### 厳格さには理由あり
- 制約なしにループ処理と更新が同時にできるようなコレクションを設計するのは難しい
- Javaの `Hashtable`，C++の `vector`，Pythonの辞書やJavaScriptのオブジェクトも，そのようなアクセスが生じたときに何が起こるかを定義していない
- C++の `std::map` は，新しいエントリを挿入してもmap中の他のエントリへのポインタが無効にならないことを約束している
- その約束によって，Rustの `BTreeMap` で用いられているような，ツリーの各ノードに複数のエントリを保持することでキャッシュ利用率を向上させる設計が使えていない

---
#### Rustのルールで捕捉できる別の種類のバグ1
- ファイルディスクリプタを管理することを意図したC++コード例
- コンストラクタとコピー代入演算子だけを示す，エラー処理は省略
```cpp
struct File {
    int descriptor;

    File(int d) : descriptor(d) { }

    File& operator=(const File &rhs) {
        close(descriptor);
        descriptor = dup(rhs.descriptor);
        return *this;
    }
};
```

---
#### Rustのルールで捕捉できる別の種類のバグ2
- 代入演算子は単純だが，自己代入をするとひどいことになる
```cpp
File f(open("foo.txt", ...));
...
f = f;
```
- `File` をそれ自体に代入すると，`rhs` と `*this` が同じオブジェクトを指すことになり，`operator=` が次に `dup` に渡そうとしているファイルディスクリプタそのものをクローズしてしまう
- コピーしようとした資源を壊してしまうということ

---
#### Rustのルールで捕捉できる別の種類のバグ3
- Rustで同じようなコードを書くと次のようになる
```rust
struct File {  // 実はもっと綺麗に書ける，9章を参照
    descriptor: i32
}

fn new_file(d: i32) -> File {
    File { descriptor: d }
}

fn clone_from(this: &mut File, rhs: &File) {
    close(this.descriptor);
    this.descriptor = dup(rhs.descriptor);
}
```

---
#### Rustのルールで捕捉できる別の種類のバグ4
- 自己代入してみると，ちゃんとコンパイルエラー
```rust
let mut f = new_file(open("foo.txt", ...));
...
clone_from(&mut f, &f);
```

```
error[E0502]: cannot borrow `f` as immutable because it is also borrowed as mutable
  --> references_self_assignment.rs:18:25
   |
18 | clone_from(&mut f, &f);
   |                 -   ^- mutable borrow ends here
   |                 |   |
   |                 |   immutable borrow occurs here
   |                 mutable borrow occurs here
```

---
#### Rustは古典的なバグを避けられる
- 自己代入を処理し損ねるバグと，無効になったイテレータを使ってしまうバグという，C++の2 つの古典的なバグの大本は同じバグだと分かる！
- いずれの場合も，ある値を参照しながら別の値を変更しようとしているが，実際には同じ値を使っている
- 変更アクセスを排他的にすることで，Rustはさまざまな種類のよくあるバグを避けることができる

---
#### Rustの共有参照 vs Cの `const` へのポインタ1
- Rustの共有ポインタはCとC++の `const` 値へのポインタによく似ているよう
に見えるが，Rustの共有参照のルールははるかに厳格
- Cのコード例
```cpp
int x = 42;         // int変数，constではない
const int *p = &x;  // const intへのポインタ
assert(*p == 42);
++x;                // 変数を直接変更
assert(*p == 43);   // "const"のはずの参照先の値が変わっている
```

---
#### Rustの共有参照 vs Cの `const` へのポインタ2
- `p` が `const int*` であるということは，この `p` を通じて参照先を変更することができないという意味
- `(*p)++` とはできないが，直接 `x` を使って参照先に到達することができる
- `x` は `const` ではないので，変更可能
- CとC++の `const` はそれなりの使いみちがあるが，本当に変化しないわけではない

---
#### Rustの共有参照 vs Cの `const` へのポインタ3
- Rustでは，共有参照はその生存期間が終了するまで，参照先へのすべての変更を禁止する
```rust
let mut x = 42;      // 可変なi32値
let p = &x;          // i32への共有参照
assert_eq!(*p, 42);
x += 1;              // エラー: xは借用されているので代入できない
assert_eq!(*p, 42);  // 上の行の代入を取り除くと，このアサートは成立する
```

---
#### Rustの共有参照 vs Cの `const` へのポインタ4
- 値が変わらないことを保証するためには，その値へのすべての可能なパスを調べ，そのパス
が変更を許さないことを確認し，変更を許すパスは使えないようにする必要がある
- CとC++のポインタは十分に制約されていないため，このようなチェックを行うことができない
- Rustの参照は常に特定の生存期間と結び付けられいて，コンパイル時にチェックできるよう
になっている

---
#### 並列化での利点
- 共有参照と可変参照が混在できないことは，並列コードを書く際に真価を発揮する
- データの競合は，ある値が可変でしかもスレッド間で共有されている場合にだけ起きるため，Rustの参照ルールはまさにこのような状況を排除する
- `unsafe` コードのないRustの並列プログラムは，構造上データ競合が生じ得ない
- 19章で詳しく述べるが，Rustでは他のほとんどの言語と比べて，はるかに簡単に並列プログラミングができる

---
### 5.3.1　オブジェクトの海に立ち向かう
- 1990年代に自動的なメモリ管理が興隆してから，すべてのプログラムは図5-10に示すような **オブジェクトの海** (sea of objects) を基本的な構造とするようになった
- ガベージコレクションが使える環境で，まったく事前に設計しないでプログラムを書き始めるとこのようになる
- メリットもたくさんある：作り始めのうちは素早く進捗を上げられ，手軽に変更することもでき，数年経ったら完全に書き直すことを正当化する理由に事欠かない（[ここでAC/DC の「Highway to hell」をかける](https://www.youtube.com/watch?v=l482T0yNkeo)）

---
#### オブジェクトの海の欠点
- すべてのものがすべてのものに依存している
- テストするのも，改良するのも大変
- 個別のコンポーネントを分離して考えることすら難しい（疎結合でない）

---
#### Rust の素晴らしい点
- 所有権のモデルが地獄へのハイウェイにスピードバンプを作ってくれる
- Rustでは，2つの値が相互を指す参照を持つようなサイクル構造を作るのに手間がかかる（`Rc` のようなスマートポインタ型を使い，まだ説明していない内部可変性を用いなければならない）
- Rustは，ポインタも所有権もデータフローも，図5-11に示すように一方向に流れることを好む

---
#### おわりに
- `Rc` スマートポインタで「構造体の海」を作って慣れ親しんだオブジェクト指向のアンチパターンをすべて再現したくなるだろうが，Rustの所有権モデルのためこれはそんなに簡単にはいかない
- Rustでは，前もって設計して良いプログラムを書くしかない
- Rustの本質は，プログラムを理解する苦労を，未来から現在に移すことにある
- Rustは，なぜプログラムがスレッド安全なのか理解することを強要するだけでなく，高度な構成上の設計をも要求する
