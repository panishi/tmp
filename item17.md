# Item17：自動的に生成される特殊メンバ関数を理解する
## はじめに
C++の正式用語で **特殊メンバ関数** (special member function) とは，C++が自ら生成するメンバ関数を意味する．
C++98には特殊メンバ関数が4つ（デフォルトコンストラクタ，デストラクタ，コピーコンストラクタ，コピー代入演算子）がある．
クラスが上記関数を明示的に宣言していないがコードでは使用している場合に，これらは生成される．
生成された特殊メンバ関数は暗黙に `public` かつ `inline` になり，仮想デストラクタを持つ基底クラスを継承した派生クラスのデストラクタ以外は，非仮想関数になる．
基底クラスが仮想デストラクタを持っていれば，コンパイラが生成する派生クラスのデストラクタも仮想デストラクタになる．

## C++11以降
C++11からは，ムーブコンストラクタとムーブ代入演算子の2つが追加された．
```cpp
class Widget {
public:
    …
    Widget(Widget&& rhs);  // ムーブコンストラクタ

    Widget& operator=(Widget&& rhs);  // ムーブ代入演算子
    …
};
```

生成規則や動作は，対応するコピー関数と同様である．
必要な場合にのみ生成され，その動作は非 `static` メンバ変数の「メンバ単位のムーブ」となる．
- ムーブコンストラクタは仮引数 `rhs` からクラスの非 `static` メンバ変数をそれぞれムーブコンストラクトする．
- ムーブ代入演算子は同様にムーブ代入する．

ムーブコンストラクタは基底クラス部分（もしあれば）もムーブコンストラクトし，ムーブ代入演算子も同様に基底クラス部分を含めムーブ代入する．

## ムーブ要求について
上記が実際にムーブ動作になるかは保証されていない．
「メンバ単位のムーブ」とは実際には，ムーブ非対応な型（ムーブ演算用の対応を実装していない型．C++98のほとんどの古いクラスが該当）はコピー演算により「ムーブ」されるため，メンバ単位のムーブ要求と言った方が適切だろう．
メンバ単位の「ムーブ」の核となるのはムーブ元オブジェクトを処理する `std::move` であり，その結果からムーブ演算かコピー演算のどちらを実行するかを決定する関数オーバロードを解決する（Item23を参照）．
本項目では単に，メンバ単位のムーブとはムーブ演算に対応しているメンバ変数や基底クラスのムーブ演算を指す．
ムーブ演算に対応していなければこれはコピー演算になるとは覚えておこう．

## ムーブ演算が生成される条件
コピー演算同様に，ムーブ演算を明示的に宣言すればムーブ演算は生成されません．
ムーブ演算生成の厳密な条件はコピー演算の場合とわずかに異なる．

コピーコンストラクタ，コピー代入の2つのコピー演算は独立しており，一方を宣言してもコンパイラが他方を生成するのを抑制したことにはならない．
コピーコンストラクタは宣言したがコピー代入演算子は宣言しない場合でも，コピー代入するコードを記述すればコンパイラはコピー代入演算子を自動的に生成する．
これはC++11でも変わらない．

ムーブ演算の場合では，上記のような独立性はない．
どちらか一方を宣言すれば，コンパイラは他方も生成しない．
例えばムーブコンストラクタを宣言すれば，コンパイラが生成するデフォルトのメンバ単位のムーブとは異なる，何か特別な処理が必要なことが示唆される．
もしメンバ単位のムーブコンストラクトでは問題となるならば，恐らくはメンバ単位のムーブ代入でも問題となるだろう．
そのため，ムーブコンストラクタを宣言すればムーブ代入演算子は生成されず，ムーブ代入演算子が宣言されればコンパイラは同様にムーブコンストラクタを生成しない．
（話者注）コピーの場合も，自前で書いたら特別な意味論でのコピーが期待さえるのでは．この説明はあまり理由になっていない気がする．

さらに，コピー演算を明示的に宣言したクラスの場合にもムーブ演算は生成されない．
コピー演算の宣言とは，通常のコピー演算（メンバ単位のコピー）ではそのクラスにふさわしくないことを示唆するためである．
コンパイラは，メンバ単位のコピーがふさわしくないならば，ムーブ演算にメンバ単位のムーブはやはりふさわしくないと考える．

# コピー演算が削除される場合
クラス内でムーブ演算（ムーブコンストラクタかムーブ代入演算子）を宣言すると，コンパイラがコピー演算を無効に（「`= delete`」する．
つまり，そのオブジェクトのムーブ演算としてメンバ単位のムーブがふさわしくない以上，そのオブジェクトをコピーする場合でもメンバ単位のコピーがふさわしいとは考えないということ．
これではC++98コードが動作しなくなる恐れがあるように思えるかもしれないが，実際問題にはならない．
C++98にはオブジェクトの「ムーブ」という考え方自体が存在しないため，C++98コードはムーブ演算を実装できない．
従来のクラスがユーザ定義ムーブ演算を持てるのは，コードをC++11に移行し，C++11の特殊メンバ関数生成規則に従いムーブセマンティクスを活用するように修正して初めて可能となる．

## Rule of Three
**三関数同時ルール** (Rule of Three) というガイドラインが存在する．
これは，コピーコンストラクタ，コピー代入演算子，デストラクタのいずれか1つでも宣言する場合は，この3つをすべて宣言するようにというもので，何らかのリソース管理を行うクラスでは，ほとんどの場合でコピー演算の動作を引き継ぐ必要性があるという観点から導かれたルールだ．
ほぼ常に次のことが該当する．
- コピー演算の一方が何らかのリソース管理を伴うならば，もう一方のコピー演算でも同じリソース管理が恐らく必要になるだろう．
- 恐らくデストラクタでも同じリソースを管理することになるだろう（通常はリソースを解放する）．

古くから管理対象となるリソースはメモリだ．
これが標準ライブラリ内のメモリを管理する全クラス（メモリをダイナミックに管理するSTLコンテナなど）が，コピー演算もデストラクタも含め「三大関数」を宣言している理由だ．

三関数同時ルールから，ユーザがデストラクタを宣言すれば，メンバ単位のコピーはそのクラスのコピー演算には適切ではないことを示唆していると分かる．
すると，デストラクタを宣言したクラスに対してはコピー演算を自動的には生成すべきではないという考えに至る．
C++98策定時点では，この考えの持つ意味がそれほど重要視されなかったため，ユーザがデストラクタを宣言してもコンパイラのコピー演算生成には影響しなかった．
C++11でもコピー演算を生成するか否かの条件は厳しくなっていないが，その理由は単に動作しなくなる古いコードが多くなってしまうというだけだ．

しかし，C++11では三関数同時ルールという考え方が効力を発揮し，コピー演算を宣言すればムーブ演算の暗黙の生成を抑制すべきという観測結果も組み合わさり，ユーザ宣言のデストラクタを持つクラスでは **ムーブ演算を生成しない** こととされた．

クラスのムーブ演算が必要に応じ生成されるのは，次の3つの条件がすべて真の場合のみだ．
- クラスがコピー演算を宣言していない．
- クラスがムーブ演算を宣言していない．
- クラスがデストラクタを宣言していない．

## `= default` について
デストラクタやコピー演算を宣言したクラスに対するコピー演算の生成を想定したコードがあれば，C++11以降はその想定を見直すべきだ．
コンパイラが生成する関数の動作が正しいことを明示できれば，作業はとても楽になる．
C++11の「`= default`」がまさにこれを明示する．
```cpp
class Widget {
public:
    …
    ~Widget();  // ユーザ宣言したデストラクタ
    …
    Widget(const Widget&) = default;  // デフォルトのコピーコンストラクタの動作で良い
 
    Widget& operator=(const Widget&) = default;  // デフォルトのコピー代入演算子の動作で良い
    …
};
```

この方式は多態な基底クラスを定義する際に有用になる場面が多くある．
多態な基底クラスは仮想デストラクタを持つのが通例だ．
すでに仮想化されているデストラクタを継承したクラスでない限り，デストラクタを仮想化する唯一の方法は明示的な宣言だ．
デストラクタを宣言すればムーブ演算の生成が抑制されるため，ムーブ可能にする場合に「`= default`」の追加が必要になることが多くある．
ムーブ演算を宣言すればコピー演算を無効にするため，コピー可能にもする場合は「`= default`」を追加する．
```cpp
class Base {
public:
    virtual ~Base() = default;  // デストラクタの仮想化
    Base(const Base&) = default;  // コピー対応
    Base& operator=(const Base&) = default;
    Base(Base&&) = default;  // ムーブ対応
    Base& operator=(Base&&) = default;
    …
};
```

コンパイラがコピー演算，ムーブ演算を生成し，生成された関数の動作が目的に合致していたとしても，これらを明示的に宣言し「`= default`」と定義する方式は有効だ．
これにはコードの意図を強調し，きわめて分かりにくいバグを回避する効果もある．
例えば，文字列テーブルを表し，整数のIDから文字列を高速に検索可能とするクラスを考える．
```cpp
class StringTable {
public:
    StringTable() {}  // 挿入，削除．検索などの関数．
                      // コピー/ムーブ/デストラクタはない
    …
private:
    std::map<int, std::string> values;
};
```

便利なことに，クラスがコピー演算，ムーブ演算，デストラクタを宣言していなくとも，それらが使用されていればコンパイラが自動的に生成する．

このオブジェクトのデフォルトコンストラクト，デストラクタをログ出力する必要性が生まれた場合でも，容易に対応できる．
```cpp
class StringTable {
public:
    StringTable()
    {
        makeLogEntry("Creating StringTable object");  // 追加
    }

    ~StringTable()
    {
        makeLogEntry("Destroying StringTable object");  // これも追加
    }
    …  // 他の関数は先の例と変わらず
private:
    std::map<int, std::string> values;  // 先の例と変わらず
};
```

上例は妥当に見えるが，デストラクタを宣言するとムーブ演算の生成が抑制されるという大きな副作用が隠れている．
一方，コピー演算の生成は影響を受けないため，このコードはコンパイル，実行に問題がなく，機能テストにもまず合格するだろう．
このクラスはもはやムーブ不可能だが，ムーブ要求はコンパイルおよび実行されており，合格した機能テストにはムーブ演算も包含されている．
しかしこのムーブ要求は，コピー演算を実行してしまう．
すなわち，`StringTable` オブジェクトをコピーし，また内包する `std::map<int, std::string>` オブジェクトをコピーすることで「ムーブ」する．
そして，`std::map<int, std::string>` のコピーはムーブよりも桁違いにコストがかかり，クラスにデストラクタを追加しただけで，きわめて大きな性能問題につながる恐れがある！
「`= default`」を用い，コピー演算およびムーブ演算を明示的に定義しておけば，この性能問題を防ぐことができる．

## おわりに
特殊メンバ関数に関するC++11の規則は次のようになる．
- デフォルトコンストラクタ  
C++98と同じ規則．
コンストラクタを宣言しないクラスの場合にのみ生成される．
- デストラクタ  
本質的にC++98と同じ規則．
唯一異なるのは，デフォルトで `noexcept` となる点である（Item14を参照）．
C++98同様に，基底クラスのデストラクタが `virtual` の場合にのみ `virtual` となる．
- コピーコンストラクタ  
実行時の動作はC++98と同様に，非スタティックなメンバ変数ごとにコピーすることでコンストラクトする．
コピーコンストラクタを宣言しないクラスの場合にのみ生成される．
ムーブ演算を宣言したクラスの場合は「`= delete`」される．
コピー代入演算やデストラクタを宣言したクラスに対するコピーコンストラクタの生成は非推奨とされている．
- コピー代入演算子  
実行時の動作はC++98と同様に，非スタティックなメンバ変数ごとにコピー代入する．
コピー代入演算子を宣言しないクラスの場合にのみ生成される．
ムーブ演算を宣言したクラスの場合は「`= delete`」される．
コピーコンストラクタやデストラクタを宣言したクラスに対するコピー代入演算の生成は非推奨とされている．
- ムーブコンストラクタおよびムーブ代入演算子  
いずれも非スタティックなメンバ変数ごとにムーブする．
コピー演算，ムーブ演算，デストラクタいずれも宣言しないクラスの場合にのみ生成される．

テンプレートメンバ関数の存在がコンパイラの特殊メンバ関数自動生成を抑制することはない点に注意しよう．
```cpp
class Widget {
    …
    template <typename T>  // どんなものからでもWidgetを作成
    Widget(const T& rhs);

    template <typename T>  // どんなものからでもWidgetへ代入
    Widget& operator=(const T& rhs);
    …
};
```

上例では，テンプレート関数がコピーコンストラクタおよびコピー代入演算子と同じシグネチャを生成する場合（`T` が `Widget` だった場合）があるにも関わらず，コンパイラは `Widget` のコピー演算，ムーブ演算を生成可能だ．
この例は意識するに値しない極端な場合だと思うかもしれない（恐らく間違いなくそうだ）が，ここで取り上げたのには理由がある．
これはItem26で解説する．

## Things to remember
- 特殊メンバ関数とはコンパイラ自らが生成するものである．
デフォルトコンストラクタ，デストラクタ，コピー演算，ムーブ演算である．
- ムーブ演算は，ムーブ演算，コピー演算，デストラクタのいずれも明示的に宣言していないクラスに対してのみ生成される．
- コピーコンストラクタは，コピーコンストラクタを明示的に宣言していないクラスに対してのみ生成され，ムーブ演算を宣言した場合には「`= delete`」される．
コピー代入演算子は，コピー代入演算子を明示的に宣言していないクラスに対してのみ生成され，ムーブ演算を宣言した場合には「`= delete`」される．
デストラクタを明示的に宣言したクラスに対するコピー演算の生成は非推奨とされている．
- テンプレートメンバ関数が特殊メンバ関数の生成を抑制することはない．
