# Item7：オブジェクト作成時の `()` と `{}` の違い
## はじめに
意見の分かれるところだが，C++11でのオブジェクト初期化構文の選択には，種類が豊富なゆえの当惑，もしくは見苦しい混乱があった．
オブジェクト初期化構文には，丸括弧（`()`），等号（`=`），波括弧（`{}`）を使用する．
```cpp
int x(0);    // 丸括弧を用いた初期化子
int y = 0;   // 等号を用いた初期化子
int z{ 0 };  // 波括弧を用いた初期化子
```

多くの場合，等号と波括弧は併用できる．
```cpp
int z = { 0 };  // 等号と波括弧を併用した初期化子
```

C++では等号と波括弧の併用は波括弧のみの場合と同じため，本項目ではこの併用については取り上げない．

## 「見苦しい混乱」の主張
「見苦しい混乱」を主張勢からは，初期化時の等号を代入演算と勘違いするC++初心者が多いと指摘されている．
初期化と代入の区別は，ユーザ定義型の場合には大きな意味を持つ．
```cpp
Widget w1;       // デフォルトコンストラクタを呼び出す
Widget w2 = w1;  // 代入ではない，コピーコンストラクタを呼び出す
w1 = w2;         // 代入である，コピー演算子operator=を呼び出す
```

初期化構文が複数あっても，C++98では目的通りの初期化を表現できない場面があった．
例えば，ある特定の値を持つSTLコンテナの作成を直接的に表現できなかった．

（話者注）つまり，いちいち以下のように書かなくてはならなかった．
```cpp
std::vector<int> v;
v.push_back(1);
v.push_back(3);
v.push_back(5);
```

## 初期化の統一記法（波括弧による初期化）
初期化構文が複数存在することによる混乱，すべての初期化処理に対応できていないことによる混乱を解消するため，C++11では **初期化の統一記法** (uniform initialization) が導入された．
初期化の統一記法では波括弧を用いるため，著者は **波括弧による初期化** (braced initialization) という用語を好んで使用する．

波括弧による初期化を用いると，これまでは表現できなかったものも表現可能となる．
コンテナの初期要素の指定も，波括弧を用いれば容易になる．
```cpp
std::vector<int> v{ 1, 3, 5 };  // vの初期要素は1，3，5
```

波括弧は，非スタティックなメンバ変数のデフォルト初期値を指定する場合にも使用できる．
C++11で追加されたこの構文は「`=`」の初期化構文と同じ様に使用できます．
一方で，丸括弧は使用できない．
```cpp
class Widget {
…
private:
    int x{ 0 };  // 問題なし，xのデフォルト値は0
    int y = 0;   // これも問題なし
    int z(0);    // エラー！
};
```

コピー不可能なオブジェクト（`std::atomic` など，Item40を参照）は，波括弧でも丸括弧でも初期化できるが，「`=`」では初期化できない．
```cpp
std::atomic<int> ai1{ 0 };  // 問題なし
std::atomic<int> ai2(0);    // 問題なし
std::atomic<int> ai3 = 0;   // エラー！
```

以上の例を見れば，波括弧による初期化を「統一 (uniform)」と呼ぶ理由が分かるだろう．
C++の3種類の初期化式のうち，どこでも使えるのは波括弧だけだ．

## 精度が落ちる変換を防ぐ
波括弧による初期化には，組み込み型の暗黙の **精度が落ちる変換**（narrowing conversion，桁落
ち変換）を認めないという特長もある．
波括弧で囲んだ初期化子式の値が初期化対象オブジェクトの型で表現できる保証がなければ，そのコードはコンパイラによって警告されるか，もしくはコンパイルエラーとなる．
```cpp
double x, y, z;
…
int sum1{ x + y + z };  // エラー！doubleの和はintでは表現できない恐れがある
```

丸括弧および「`=`」を用いた初期化では，精度が落ちる変換をチェックしない．
```cpp
int sum2(x + y + z);   // コンパイルOK（式の値はintに切り詰められる）
int sum3 = x + y + z;  // 同上
```

（話者注）とはいえ，通常のコンパイラなら何らかの警告は出るのでは…？

## 最も厄介な構文解析を回避する
波括弧による初期化は，C++の **最も厄介な構文解析** (most vexing parse) という問題を回避できる．
最も厄介な構文解析とはC++の文法の副作用で，宣言と解析できるものならば何でも宣言と解釈しなければならないというもの．
この点から，オブジェクトのデフォルトコンストラクタのつもりにも関わらず，意図せずに関数宣言となってしまうことがあり，開発者をとても悩ませる．
以下の例を考える．
```cpp
Widget w1(10);  // 実引数10を与えWidgetのコンストラクタを呼び出す
```

同様の構文で実引数を与えずに `Widget` のコンストラクタを呼び出そうとしても，オブジェクトではなく関数を宣言することになってしまう．
```cpp
Widget w2();  // 最も厄介な構文解析！Widgetを返すw2という関数を宣言している！
```

仮引数の並びを波括弧で囲んだ関数宣言は認められていないので，オブジェクトのデフォルトコンストラクト時に波括弧を用いればこの問題は発生しない．
```cpp
Widget w3{};  // 実引数を与えずにWidget のコンストラクタを呼び出す
```

## なぜ本項目のタイトルが「波括弧による初期化構文を優先せよ」でないか…
ここまででの例では，波括弧はいいことづくめなので波括弧による初期化構文を優先すべきように思えるが，本項目のタイトルをそうしなかったのには理由がある．

波括弧で囲んだ初期化子，`std::initializer_list`，コンストラクタのオーバロード解決が複雑に絡み合うと，見た目と実行内容が異なるコードが生まれることがある．
例えば，Item2でも述べたように，`auto` で宣言した変数に波括弧で囲んだ初期化子を与えると，推論される型は `std::initializer_list` になる．
`auto` の使用頻度が上がるほど，波括弧による初期化に対しては消極的になる傾向がある．

コンストラクタを呼び出す場合，`std::initializer_list` 仮引数が関与しなければ丸括弧と波括弧は同じ意味だ．
```cpp
class Widget {
public:
    Widget(int i, bool b);    // std::initializer_listを用いない2コンストラクタ
    Widget(int i, double d);
    …
};

Widget w1(10, true);  // 1番目のコンストラクタを呼び出す
Widget w2{10, true};  // やはり1番目のコンストラクタを呼び出す
Widget w3(10, 5.0);   // 2番目のコンストラクタを呼び出す
Widget w4{10, 5.0};   // やはり2番目のコンストラクタを呼び出す
```

しかし，`std::initializer_list` 型の仮引数を持つコンストラクタを1つでも宣言し，波括弧に
よる初期化を実行すると，そのオーバロードを実行する方向に **大きく傾く**．
コンパイラから見て，波括弧で囲んだ初期化子が `std::initializer_list` を用いたコンストラクタ呼び出しであると **少しでも** みなせれば，コンパイラはそのように解釈する．
例えば上例の `Widget` に，`std::initializer_list<long double>` をとるコンストラクタをオーバーロードしてみる．
```cpp
class Widget {
public:
    Widget(int i, bool b);    // 先の例と同じ
    Widget(int i, double d);
    Widget(std::initializer_list<long double> il);  // 追加
    …
};
```

`w2` と `w4` の `Widget` は，新たに追加したコンストラクタにより作成される．std::initializer_list をとらないコンストラクタと比較して，実引数が2つとも
std::initializer_list の要素の型 (`long double`) との一致度が劣るにも関わらずだ！
```cpp
Widget w1(10, true);  // 先の例と同様に，丸括弧を用い，1番目のコンストラクタを呼び出す
Widget w2{10, true};  // 波括弧を用いるが，今度はstd::initializer_listのコンストラクタを呼び出す
                      // （10とtrueはlong doubleに変換される）
Widget w3(10, 5.0);   // 先の例と同様に，丸括弧を用い，2番目のコンストラクタを呼び出す
Widget w4{10, 5.0};   // 波括弧を用いるが，今度はstd::initializer_listのコンストラクタを呼び出す
                      // （10と5.0はlong doubleに変換される）
```

通常ならばコピーやムーブによるコンストラクトが実行される場面でも，`std::initializer_
list` のコンストラクタに乗っ取られることがあり得る．
```cpp
class Widget {
public:
    Widget(int i, bool b);  // 先の例と同様
    Widget(int i, double d);
    Widget(std::initializer_list<long double> il);

    operator float() const;  // floatへ変換
…
};

Widget w5(w4);  // 丸括弧，コピーコンストラクタを呼び出す
Widget w6{w4};  // 波括弧，std::initializer_listのコンストラクタを呼び出す
                // （w4はfloatに変換後long doubleへ再変換される）
Widget w7(std::move(w4));  // 丸括弧，ムーブコンストラクタを呼び出す
Widget w8{std::move(w4)};  // 波括弧，std::initializer_listのコンストラクタを呼び出す
                           // （w6と同様に変換される）
```

「波括弧の初期化子は `std::initializer_list` をとるコンストラクタに一致する」というコンパイラの判断は非常に強く，`std::initializer_list` をとるコンストラクタを呼び出せない場合でもその判断は維持される．
```cpp
class Widget {
public:
    Widget(int i, bool b);    // 先の例と同様
    Widget(int i, double d);
    Widget(std::initializer_list<bool> il);  // 要素の型がboolになった
                                             // 暗黙の変換関数は存在しない
…
};

Widget w{10, 5.0};  // エラー！精度が落ちる変換を伴うため
```

コンパイラは2つのコンストラクタを無視し（2番目のコンストラクタが2つの実引数の型に完全に一致するにも関わらず），`std::initializer_list<bool>` をとるコンストラクタを呼び出そうとする．
波括弧で囲んだ初期化子では精度が落ちる変換は禁止されるため，このコンストラクタ呼び出しは不正となりコンパイルできない．

コンパイラがオーバロードを通常通りに解決できるのは，波括弧で囲んだ初期化子の実引数の型を `std::initializer_list` 内の型へ変換する方法が存在しない場合のみ．
上例の `std::initializer_list<bool>` をとるコンストラクタを `std::initializer_list<std::string>` をとるように変更すると，`std::initializer_list` 以外のコンストラクタがコンパイラの検討対象に復活する．
これは，`int` と `bool` を `std::string` へ変換する方法が存在しないため．
```cpp
class Widget {
public:
    Widget(int i, bool b);    // 先の例と同様
    Widget(int i, double d);  // 先の例と同様
    // std::initializer_listの要素の型をstd::stringに変更
    Widget(std::initializer_list<std::string> il);
    …  // 暗黙の変換関数は存在しない
};
    
Widget w1(10, true);  // 丸括弧，1番目のコンストラクタを呼び出す
Widget w2{10, true};  // 波括弧，1番目のコンストラクタを呼び出す
Widget w3(10, 5.0);   // 丸括弧，2番目のコンストラクタを呼び出す
Widget w4{10, 5.0};   // 波括弧，2番目のコンストラクタを呼び出す
```

まだ解決しなければならない特殊な場合がある．
デフォルトコンストラクタと`std::initializer_list` をとるコンストラクタを両方持つクラスのオブジェクトを，空の初期化子を波括弧で囲んで与え (`{}`) 作成する場合を考えよう．

この場合，デフォルトコンストラクタに解決すると定められている．
空の波括弧は実引数がないという意味であり，空の `std::initializer_list` という意味にはならない．
```cpp
class Widget {
public:
    Widget();  // デフォルトコンストラクタ
    Widget(std::initializer_list<int> il);  // std::initializer_listをとるコンストラクタ
    …  // 暗黙の変換関数は存在しない
};

Widget w1;    // デフォルトコンストラクタを呼び出す
Widget w2{};  // やはりデフォルトコンストラクタを呼び出す
Widget w3();  // 最も厄介な構文解析！関数宣言となる！
```

空の `std::initializer_list` を与え `std::initializer_list` をとるコンストラクタを呼び出したい場合，コンストラクタの実引数に空の波括弧を与えればよい．
つまり，丸括弧もしくは波括弧内に空の波括弧を記述する．
```cpp
Widget w4({});  // 空の並びを与えstd::initializer_listをとるコンストラクタを呼び出す
Widget w5{{}};  // 同上
```

## 以上の規則がどの程度日々の開発業務に影響するか
どれほど影響するかと問われれば，これは想像以上である．
直接影響を受けるクラスの1つに `std::vector` がある．
`std::vector` コンストラクタに実引数を2つ与えて数値型を持つ `std::vector` を作成する場合，実引数を丸括弧で囲むか，波括弧で囲むかで大きな違いが生まれる．
```cpp
std::vector<int> v1(10, 20);  // std::initializer_listではないコンストラクタ
                              // 10個の要素を持つstd::vectorを作成，値はすべて20
std::vector<int> v2{10, 20};  // std::initializer_listをとるコンストラクタ
                              // 2個の要素を持つstd::vectorを作成，値は10と20
```

### クラス開発者としての視点
`std::initializer_list` をとるコンストラクタがありオーバロードする場合，波括弧による初期化を使用するクラス利用者が目にするのは `std::initializer_list` をとるコンストラクタのみになってしまう．
そのため，クラス利用者が丸括弧を記述しても波括弧を記述しても，差異がないようにオーバロード解決できるコンストラクタ設計が求められる．
言い換えると，`std::vector `のインタフェースには設計上の誤りがある.
自身で開発するクラスでは同じ轍を踏まないようにしなければならない．

`std::initializer_list` をとるコンストラクタを実装していないクラスについて，クラス開発者が `std::initializer_list` をとるコンストラクタを追加したとする．
クラス利用者が波括弧により初期化した場合，これまで非 `std::initializer_list` のコンストラクタを呼び出していたコードが，この追加により `std::initializer_list` をとるコンストラクタを呼び出すようになってしまうかもしれない．
オーバロード関数を追加すると，オーバロード解決し既存の関数を呼び出していたコードが新規関数を呼び出すように変わってしまう問題は容易に起こり得る．
`std::initializer_list` をとるコンストラクタのオーバロードの場合は単に競合するだけでなく，他のコンストラクタに解決しようとする機会をほとんど奪ってしまうため熟慮が必須となる．

### クラス利用者としての視点
オブジェクト作成時の丸括弧・波括弧は慎重に選択する必要がある．
多くの開発者はどちらか一方を基本的に使用すると決め，もう一方はそうせざるを得ない時にのみ使用するとしている．
- 波括弧派は，適用可能範囲の無敵の広さ，精度が落ちる変換の排除，C++の最も厄介な構文解析を回避できる点を重視する．
この人々は丸括弧が必要になる場面があることを理解しているだろう（要素数と要素の初期値を与えて `std::vector` を作成するなど）．
- 丸括弧行け行け集団は，丸括弧を基本とする立場をがっちり押さえて離さない．
従来のC++98構文との一貫性，`auto` が `std::initializer_list` を推論する問題を回避できる点，不用意に `std::initializer_list` をとるコンストラクタで痛い思いをしない点を重視する．
この人々も波括弧しか使用できない場面があることは承知している（特定の値を持つコンテナの作成など）．

どちらを基本とした方が良いかという点について，広く一致した意見はない．
著者からのアドバイスは，「どちらか一方を選択しそれを徹底するようにしておけば良い」というものだけだ．

## テンプレート開発の場合
テンプレート開発者ならば，オブジェクト作成時の丸括弧と波括弧の問題には，特に神経を尖らせることになる．
どちらを使用すべきかについて判断できないのが一般的．
例えば，実引数の個数を任意とし，任意の型のオブジェクトを作成する場合を考える．
```cpp
template <typename T,      // 作成するオブジェクトの型
          typename... Ts>  // 基となる実引数の型
void doSomeWork(Ts&&... params)
{
    // params...からローカルなTオブジェクトを作成
    …
}
```

上例の疑似コードを実際のコードへ変換する方法は2つある（`std::forward` についてはItem25を参照）．
```cpp
T localObject(std::forward<Ts>(params)...);  // 丸括弧を使用
T localObject{std::forward<Ts>(params)...};  // 波括弧を使用
```

呼び出し箇所も考えてみる．
```cpp
std::vector<int> v;
…
doSomeWork<std::vector<int>>(10, 20);
```

`doSomeWork` が `localObject` を作成する際に
- 丸括弧を使用すると，10個の要素を持つ `std::vector`
- 波括弧を使用すると，2個の要素を持つ `std::vector`

と違う結果を得る．
正しいのはどちらか `doSomeWork` の開発者には知る術がなく，`doSomeWork` の利用者にしか分からない．

標準ライブラリの `std::make_unique` と `std::make_shared` はまさにこの問題に直面している．
Item21を参照．
これらではインタフェースの一部として，内部で丸括弧を使用していることを明文化している．

## Things to remember
- 最も広範囲に使用可能な初期化構文は波括弧による初期化である．
精度が落ちる変換を防ぎ，C++の最も厄介な構文解析を回避できる．
- 波括弧で囲んだ初期化子は，コンストラクタのオーバロード解決時に，見た目ではより高く一致するコンストラクタが他にあっても，仮引数が一致すれば `std::initializer_list` をとるコンストラクタに解決される．
- 丸括弧か波括弧かの選択が大きな差異を生む例としては，実引数を2つ与えた `std::vector<numeric type>` の作成がある．
- テンプレート内でのオブジェクト作成に，丸括弧，波括弧のどちらを使用するかを選択するのは，楽しいながらも大変な挑戦になるだろう．
