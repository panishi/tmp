---
marp: true
transition: "slide"
slideNumber: true
---
<!-- theme: gaia -->
<!-- size: 16:9 -->
<!-- page_number: true -->
<!-- paginate: true -->

<style>
img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
</style>

# Effective C++
Item 19: クラスのデザインを型のデザインとして考えよう

2021/x/x

---
### はじめに
- 他のオブジェクト指向言語と同様に，C++では，クラスは新しい型になる．
- C++プログラマは，クラスの（つまりは型の）デザイナーである．
- 言語のデザイナーが組み込み型のデザインに払うような注意を，自分のクラスのデザインに払わなくてはならないということだ．

---
### 良いクラスをデザインするということ
- 良い組み込み型をデザインすることと同様に，やりがいのあることだ．
- 良い型には，自然な構文があり，直観的に分かりやすい意味があり，1つ以上の効率的な実装があるものだ．
- デザインが悪いと，これらの実現は不可能．

---
### 良いクラスをデザインするためには
- まずは，直面する問題を理解しなければならない．
- ほとんど全てのクラスで，C++プログラマは次のような問題に直面する．
- これらの問題に対する答えが，クラスデザインへの制約になる．

---
#### 新しい型のオブジェクトはどのように生成され，<br>破棄されるのか？
- オブジェクトの生成と破棄の仕方は，クラスのコンストラクタとデストラクタに影響を与える．
- プログラマが自分で書くならば，メモリの確保・解放の関数（`new` 演算子，`new[]` 演算子，`delete` 演算子，`delete[]` 演算子．8章を参照のこと）のデザインにも関わる．

---
#### オブジェクトの初期化と代入は，異なる操作になるか？
- この問題に対する答えによって，コンストラクタとコピー代入演算子の振舞いが決まる．
- 初期化と代入では異なる関数が呼ばれ，一般には別物であることを理解するべきだ（Item 4を参照）．

---
#### 新しい型のオブジェクトの値渡しは，具体的にどのような<br>ものになるか？
- クラスのオブジェクトの値渡しは，コピーコンストラクトで定義されることを思い出しておこう．

---
#### 新しい型のオブジェクトが持てる有効な値はどのようなものになるか？
- クラスのデータメンバの値としては，特定の組み合わせのものだけが有効になることがよくある．
- このような組み合わせは，クラスが維持すべき「クラスにおける不変な条件」になる．
- この「不変な条件」は，メンバ関数，特にコンストラクタ，コピー代入演算子，データ設定用関数のエラーチェックに使える．
- メンバ関数の投げる例外にも影響を与え，うまく利用すれば，例外の特定にも使える．

---
#### 新しい型は継承の階層の中にうまくあてはまるか？
- 既存のクラスの派生クラスを作る場合，それらは基底クラスのデザインに縛られることになる．
- 特に，基底クラスの関数が仮想であるかどうかは重要（Item 34, 36を参照）．
- また，自分のクラスから派生クラスを作れるようにするならば，メンバ関数，特にデストラクタ（Item 7を参照）を仮想にするかどうかを考えなくてはならない．

---
#### 新しい型はどのような型変換を受けるか？
- 新しく書く型は，言わば型の海の中に置かれるが，その型はどのような型変換を受けるべきだろうか．
- もし，型 `T1` のオブジェクトが，暗黙の型変換で `T2` に変換されるようにしたいならば，`T1` に「型変換関数 (`operator T2`)」を書くか，`T2` に「`T1` 型の引数を1つ取る `explicit` でないコンストラクタ」を書かなければならない．
- 型変換を全て明示的にしたいならば，型変換を行う関数を書くが，それは上記のような「型変換関数」や「引数が1つの `explixit` コンストラクタ」とは別の関数にする（Item 15を参照）．

---
#### 新しい型で意味のある演算子や関数は何か？
- この答えにしたがって，クラスのメンバ関数を宣言することになる．
- 関数は，メンバ関数になるものとそうでないものに分かれる（
Item 23, 24, 46を参照）．

---
#### 標準的な関数で禁止すべきものは何か？
- 禁止すべき関数は `private` 宣言をする（Item 6を参照）．
- （話者注）C++11以降ならば，`= delete` を付ける．

---
#### 新しい型のメンバにアクセスできるものは何か？
- これを考えることで，どのメンバを `piblic`, `protected`, `private` にするか，考えることができる．
- どのクラスや関数を `friend` にするか，クラスの中に内部クラスを作るべきか，等も考えることができる．

---
#### 新しい型の「宣言されていないインタフェース」は何か？
-  性能，例外安全性（Item 29を参照），ロックや動的メモリ等のリソース管理に関して，保証できることは何だろうか．
- これらについて何かを保証すれば，クラスの実装に制限が加わることになる．

---
#### 新しい型はどのくらい一般的か？
- 新しい型を1つではなく，まとめて定義したいこともあるだろう．
- その場合は，クラスではなく，クラステンプレートを定義するとよいだろう．

---
#### 本当に新しい型が必要なのか？
- 既存のクラスに機能を付け加えるためだけに，そのクラスの派生クラスを作るなら，いくつかメンバでない関数やテンプレートを定義した方がよいかもしれない．

---
### おわりに
- これらの問に答えることは簡単ではないが，だからこそ，新しく良いクラスを定義することはやりがいがある．
- うまくこれらを達成できれば，C++の中に，少なくとも組み込み型と同じくらい良い型を定義したことになる．
- それは，努力に値することだろう．

---
### Things to Remember
- クラスのデザインは，型のデザイン．新しい型を定義する前に，この項に挙げたすべての問を考えてみよう．
