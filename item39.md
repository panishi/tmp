# Item 39：イベントが1度切りならば `void` な future を検討する
## はじめに
ある特定のイベントが発生した場合に，第2のタスクを非同期に実行させると有用な場面がある（データの初期化が完了した，計算の準備が整った，センサが異常な値を検知した等）．
このような場面でのスレッド間通信の最適な方法とは何だろうか？

## 条件変数
分かりやすい方法は **条件変数** (condition variable, condvar) だ．
条件を検知するタスクを **検知タスク** (detecting task)，条件に反応し処理を開始するタスクを **反応タスク** (reacting task) と呼ぶ．
反応タスクは条件変数でウェイトし，検知タスクはイベント発生を条件変数に通知する．
```cpp
std::condition_variable cv;  // イベント用の条件変数
std::mutex m;                // cv に使用する mutex
```

### 検知タスク
この上ないほど簡単．
```cpp
…                 // イベントを検知
cv.notify_one();  // 反応タスクへ通知
```

反応タスクが複数存在する場合 `notify_one` を `notify_all` に置き換える必要がある．
ここでは反応タスクは1つしか存在しないものとする．

### 反応タスク
条件変数を `wait` する前に，`std::unique_lock` 経由で mutex をロックする必要がある．
```cpp
…                                        // 反応処理の準備
{                                        // クリティカルセクション開始
    std::unique_lock<std::mutex> lk(m);  // mutex をロック
    cv.wait(lk);                         // 通知をウェイトする．これは誤り！
    …                                    // イベント反応処理（m はロックされている）
}                                        // クリティカルセクション終了．lk のデストラクタから m をアンロック
…                                        // イベント反応処理の続き（m はアンロックされている）
```

上例のコードは動作するかもしれないが，何かが誤っている．
「何か匂うぞこのコード」 (codesmell) と称される類の代物だ．

原因は mutex の必要性にある．
共有データのアクセス制御に mutex を使用しているが，検知タスクと反応タスク間でデータの共有は一切不要にできる．
検知タスクがグローバルデータの初期化をし，グローバルデータを使用するのが反応タスクとすれば良い．
検知タスクは初期化後にデータを使用せず，反応タスクも初期化が完了するまでデータを使用しなければ，2タスクの処理は独立となり mutex は必要ない．
設計が疑わしいという不穏な香りの影には，mutex を必要とするような条件変数を用いた方式が隠れている．

問題点は他にも2点ある．

### 反応タスクが条件変数で `wait` するより先に検知タスクが通知すると，反応タスクがハングする
別タスクのウェイクアップを目的とした条件変数の通知では，別タスクがその条件変数でウェイトしていなければならない．
反応タスクが `wait` する前に検知タスクが通知を実行しても，反応タスクはその通知を受け取れず永久にウェイトし続けてしまう．

### ウェイトが疑似ウェイクアップを考慮していない
スレッド API では (C++ に限らず多くの言語で)，条件変数でウェイトするコードが通知されないにも関わらずウェイクアップさせられることがある．
これを **疑似ウェイクアップ** (spurious wakeup，偽りのウェイクアップ) と言う．
ウェイクアップさせられたら，本来の処理を実行する前に必要な条件が真に満たされていると確認するのが正しい．
C++ の条件変数 API では，ウェイトしている条件を検査する関数オブジェクトを `wait` に渡せる．
```cpp
cv.wait(lk,
    []{ return whether the event has occurred; });
```
これを活かすには反応タスクが条件の真偽を判定できなければならないが，反応スレッドではイベントの発生を判断する方法が存在しない場合がある（そもそもこれが条件変数でウェイトする理由！）．

## フラグを共有する技法

### 検知タスク
フラグの初期値を `false` とし，検知スレッドが対象のイベントを検知するとフラグを `true` に変更する．
```cpp
std::atomic<bool> flag(false);  // 共有フラグ．std::atomic については Item 40 を参照
…                               // イベントを検知
flag = true;                    // 反応タスクへ通知
```

### 反応タスク
単にフラグをポーリングすればよい．
フラグが `true` になれば，イベントが発生したことが分かる．
```cpp
…               // 反応処理の準備
while (!flag);  // イベントをウェイト
…               // イベント反応処理
```

### メリット
条件変数ベースの設計が持つ短所がない．
mutex を不要にでき，反応タスクがポーリングを開始する前に検知タスクがフラグを `true` にしても問題は発生しない．
疑似ウェイクアップのような問題にも無縁．

<div align="center">
<img src="img/dimort.jpg">
</div>

### デメリット
反応タスクがポーリングするコストがかかる．
フラグが `true` になるのを待っている間，反応タスクは実質的にブロックしてる．
この動作は他のタスクがハードウェアスレッドを使用する機会を奪ってしまう．
タスクが真のブロック状態であればこのような問題は発生せず，これこそがタスクを真のブロック状態に遷移させる条件変数を用いるそもそもの利点である．

## 条件変数とフラグの組み合わせ
フラグへの同時アクセスを mutex により防止するため，Item 40 でも述べるように，フラグを `std::atomic` にする必要はなく，単純な `bool` で十分．

### 検知タスク
```cpp
std::condition_variable cv;            // 先の例と同様
std::mutex m;
bool flag = false;                     // std::atomic ではない
…                                      // イベントを検知
{
    std::lock_guard<std::mutex> g(m);  // g のコンストラクタから m をロック
    flag = true;                       // 反応タスクへ通知 (その1)
}                                      // g のデストラクタから m をアンロック
cv.notify_one();                       // 反応タスクへ通知 (その2)
```

### 反応タスク
```cpp
…                                        // 反応処理の準備
{
    std::unique_lock<std::mutex> lk(m);  // 先の例と同様
    cv.wait(lk, [] { return flag; });    // 疑似ウェイクアップ防止のためラムダを使用
    …                                    // イベント反応処理 (m はロックされている)
}
…                                        // イベント反応処理の続き (m はアンロックされている)
```

上例では先に述べた問題は発生しない．
検知タスクが通知するより先に反応タスクが `wait` しても構わないし，疑似ウェイクアップが発生しても動作する．
ポーリングする必要もない．
しかし，あの不穏な匂いはまだ漂っている．
検知タスクと反応タスクの通信方法がやはり奇妙だ．
- 条件変数を介してイベントが恐らく発生したであろうと反応タスクに通知するが，反応タスクはフラグにより確認しなければならない．
- 検知タスクは条件変数を介し反応タスクをウェイクアップし，フラグ確認をさせなければならない．

##  future で `wait` する方式
条件変数，mutex，フラグを使用せず，反応タスクは検知タスクが設定した future で `wait` する方法がある．
Item 38 では，future は呼び出された側から (通常は非同期に) 呼び出した側への通信チャネルの受信側を表現すると述べた．
ここでの検知タスク，反応タスクは呼び出す／呼び出される関係ではない．
Item 38 では，送信側を `std::promise`，受信側を future とする通信チャネルは，単なる呼び出す／呼び出される関係以上の役割を果たせるとも述べた．
ここでは，検知タスクから反応タスクへ情報（目的イベントの発生）を送信するのに使用してみよう．

設計は単純で，検知タスクは `std::promise` オブジェクトを持ち (通信チャネルの書き込み口)，反応タスクは対応する future を持つ．
検知タスクは目的のイベント発生を検知すると `std::promise` をセットする (通信チャネルへ書き込む)．
その間，反応タスクは future で `wait` する．
これにより，反応タスクは `std::promise` がセットされるまでブロックされる．

`std::promise` も future (`std::future`, `std::shared_future`) も，型仮引数をとるテンプレートだ．
仮引数が通信チャネルを介し送信するデータの型を指すが，この例には送信するデータはない．
反応タスクが必要とするのは，future がセットされることだけだからだ．
そのため，`std::promise` と future テンプレートには，通信チャネルを介し送信するデータは存在しないと指定することになる．
この型こそが `void` であり，検知タスクは `std::promise<void>` を，反応タスクは　`std::future<void>` または `std::shared_future<void>` を実行する．
検知タスクは目的のイベントが発生すると `std::promise<void>` を実行し，反応タスクは future で `wait` する．
検知タスクからデータを何も受信しなくても，反応タスクは通信チャネルを介して検知タスクが `std::promise` に `set_value` を呼び出し，`void` データを「書き込んだ」ことが分かる．

以下で例示する．
```cpp
std::promise<void> p;  // 通信チャネルのpromise
```

### 検知タスク
```cpp
…               // イベントを検知
p.set_value();  // 反応タスクへ通知
```

### 反応タスク
```cpp
…                       // 反応処理の準備
p.get_future().wait();  // p に対応する future でウェイト
…                       // イベント反応処理
```

フラグを用いた方式同様．反応タスクが `wait` するより先に検知タスクが `std::promise` をセットしても問題なく動作する．
疑似ウェイクアップも問題にならない (影響を受けるのは条件変数のみ)．
条件変数を用いた方式同様に．反応タスクは `wait` を呼び出せば真のブロック状態になるため，ウェイト中にシステムリソースを消費しない．
完璧ではなかろうか？

### 実はそうでもない
future を用いれば確かに多くの問題を回避できるが，検討すべき問題点はまだある．
Item 38 で述べたように，`std::promise` と future の間には共有ステートが存在し，共有ステートは一般にダイナミックに割り当てられる．
そのため，上記の設計にはヒープの割り当て／解放というコストがかかる．

`std::promise` がセットされるのは1度切りであろうという点はさらに重要だ．
`std::promise` と future 間の通信チャネルは，構造的に **1度しか使えない**．
この点は，複数回の通信が可能な条件変数やフラグを用いた設計と大きく異なる (条件変数は何度も通知できるし，フラグはいつでもクリア／再セット可能）．

スレッドを1度だけ一時停止状態にしたい場合 (作成直後かつスレッド関数の実行開始前)，`void future` を用いるのが妥当な選択だ．
```cpp
std::promise<void> p;

void react();       // 反応タスクの関数

void detect()       // 検知タスクの関数
{
    // スレッド作成
    std::thread t([] 
        {
            p.get_future().wait();  // future がセットされるまで t を一時停止
            react();
        });
    …               // react 呼び出し前で t は一時停止されている
    p.set_value();  // t の実行再開 (react を呼び出す)
    …               // 何か処理
    t.join();       // t を join 不可にする (Item 37 を参照)
}
```

`detect` が終了するすべての実行パスで `t` を join 不可とする処理は重要なので，Item 37 の `ThreadRAII` のような RAII クラスを用いるのが賢明だろう．
```cpp
void detect()
{
    // RAII オブジェクトの使用
    ThreadRAII tr(
        std::thread([]
            {
                p.get_future().wait();
                react();
            }),
        ThreadRAII::DtorAction::join  // 危険！ (下記を参照)
    );
    …                                 // ここで tr のスレッドは一時停止状態
    p.set_value();                    // tr のスレッド実行を再開
    …
}
```

コメントの通り，上例は見た目ほど安全ではない．
最初の「…」の部分で例外が発生すると，`p` の `set_value` が呼び出されなくなってしまい，ラムダ内の `wait` 呼び出しから戻って来なくなる．
すると，RAII オブジェクト `tr` がデストラクタでスレッドを `join` するよう設定されているため，ラムダを実行するスレッドが終了しなくなってしまう．
言い換えると，最初の「…」部分で例外が発生すると，`tr` のデストラクタが処理を完了できなくなるため，この関数はハングしてしまう．

この問題を解決する方法は複数あるが．読者に捧げる演習として残しておく．
ここでは `ThreadRAII` を使用せず，複数の反応タスクを一時停止／実行再開可能にする単純な汎化を示す．
`react` のコード内で `std::future` ではなく，`std::shared_future` を使用する点がポイント．
`std::future` のメンバ関数 `share` が，作成した `std::shared_future` オブジェクトへ共有ステートの所有権を送信することを理解すれば，コードはほぼ自明になる．
分かりにくい点は，反応スレッドそれぞれに共有ステートを参照する専用の `std::shared_future` のコピーが必要になる点のみ．
そのため，反応スレッドで実行するラムダでは，`share` から得た `std::shared_future` をコピーキャプチャする．
```cpp
std::promise<void> p;                  // 先の例と同様

void detect()                          // 今度は複数の反応タスク
{
    auto sf = p.get_future().share();  // sf の型は std::shared_future<void>
    std::vector<std::thread> vt;       // 反応スレッドのコンテナ
    for (int i = 0; i < threadsToRun; ++i) {
        vt.emplace_back([sf] {
            sf.wait();                 // sf のローカルコピーでウェイト．
            react(); });
    }
    …                                  // この「…」で例外が発生すると join 可能な std::thread オブジェクトは破棄され，
                                       // 結果的にプログラムが終了してしまう．
    p.set_value();                     // 全スレッドの実行再開
    …
    for (auto& t : vt) {               // 全スレッドを join 不可にする．
        t.join();
    }
}
```

## おわりに
future を用いた設計ではこの効果が得られる点が特筆に値する．
まさにこれが，イベント通信が1度切りの場合では上記の設計を考慮すべき理由となる．

## Things to remember
- 単純なイベント通信の場合，条件変数を用いた設計では余分な mutex が必要になり，検知タスク，反応タスクの処理に制約が生まれる．
さらに反応タスクではイベントが実際に発生したかを確認する必要もある．
- フラグを用いた設計では上記問題点を回避できるが，ポーリング動作でありブロック動作ではない．
- 条件変数とフラグの併用も可能だが，やや大げさな構造の通信となる．
- `std::promise` と future を用いた設計では上記問題点を回避できるが，共有ステート用のヒープメモリを消費する．
さらに通信が1度切りという制限がある．
