# Item 29：ムーブ演算は存在しない，コスト安でもない，使用もされないと想定する
## はじめに
ムーブセマンティクスを活用できていない型は実は多く，読者のコードはC++11を完全には活用していない恐れがある．
C++11ではムーブ演算を実装していないクラスに対してはこれを生成しようとするが，これはコピー演算，ムーブ演算，デストラクタを宣言していないクラスに対してのみだ（Item 17を参照）．
メンバ変数や基底クラスの型がムーブ演算を無効にしても（Item 11を参照），やはりコンパイラのムーブ演算生成は抑制される．
明示的にムーブ対応していないクラス，およびコンパイラがムーブ演算を生成しない型では，C++11を使用してもC++98を上回る性能は期待できない．

## ムーブ演算はコスト安とは限らない
明示的にムーブ対応した型でも，期待通りの性能向上が得られるとは限らない．
標準C++11ライブラリ内のコンテナはすべてムーブ対応しているが，コンテナのムーブがすべての場合でコスト安であると想定するのは誤り．
- 内容をムーブする真にコスト安な方法など存在しないコンテナもある．
- コンテナが実装する真にコスト安なムーブ演算が，そのコンテナの要素にとっては不十分となる場合もある．

## `std::array` の例
`std::array` は他の標準コンテナとは根本的に異なり，コンテナの内容をヒープ上に配置しない．
他のコンテナ型のオブジェクトは，コンテナの内容を保持するヒープを指すポインタのみを持つ．
内容を指すポインタを旧コンテナから新コンテナへコピーし，旧コンテナ内のポインタをヌルにするだけで済む．
```cpp
std::vector<Widget> vw1;
// vw1の要素を設定
…
// vw1をvw2へムーブ，所要時間は一定
// vw1とvw2が持つポインタのみの変更
auto vw2 = std::move(vw1);
```

`std::array` ではオブジェクト内にデータを直接保持するため，このようなポインタを持っていない．
```cpp
std::array<Widget, 10000> aw1;
// aw1の要素を設定
…
// aw1をaw2へムーブ，所要時間は線形に増加
// aw1内の全要素をaw2へムーブ
auto aw2 = std::move(aw1);
```

`aw1` 内の要素が `aw2` へムーブされている点に注目．
`Widget` がコピーよりもムーブの方が高速な型と仮定すれば，`Widget` の `std::array` をムーブする方が，同じ `std::array` をコピーするよりも高速になる．
しかし，全要素をムーブ・コピーしなければならないため，`std::array` のムーブ・コピーの計算量はいずれも線形に増加する．
これは，たびたび言われる「コンテナのムーブは現代ではポインタをいくつか代入する程度のコスト」からは程遠い状況だ．

## `std::string` の例
`std::string` は一定時間でのムーブ演算と，所要時間が線形に増加するコピー演算を備えている．
こう書くとムーブの方がコピーよりも高速のように思えるが，必ずしもそうではない．
処理系の多くは `string` に **短い文字列の最適化** (small string optimization, SSO) を実装している．
SSOでは，「短い」文字列は（例えば15文字未満），`std::string` オブジェクト内のバッファに保持し，ヒープには割り当てない．
ポインタのみをコピーする技法の適用外になるため，SSOを実装した処理系で短い文字列をムーブしても，コピーよりも高速になることはない．

## ムーブ演算がコピーとなる場合
Item 14では以下を述べた．
- 標準ライブラリの一部のコンテナ演算は例外安全性のstrong保証を備えている．
- この保証を前提とした古いC++98コードはC++11に移行しても維持される．
- コピー演算は，ムーブ演算が例外を発生させないことが分かっている場合に限り，ムーブ演算に置き換え可能である．

結果，コピー演算よりも効率的なムーブ演算を備えた型でも，またムーブ演算が適切な場面でも（ムーブ元オブジェクトが右辺値など），そのムーブ演算が `noexcept` と宣言されていないことが原因でコンパイラはコピー演算を実行する場合がある．

## C++11のムーブセマンティクスが役立たない場面
- ムーブ演算が存在しない
ムーブ元オブジェクトがムーブ演算を備えていないため，ムーブ要求はコピー要求になる．
- ムーブ演算が高速ではない
ムーブ元オブジェクトがムーブ演算を備えているが，コピー演算と比較し高速ではない．
- ムーブ演算を使用できない
例外を発生させないムーブ演算が必要な場面だが，そのムーブ演算が `noexcept` と宣言されていない．

## ムーブセマンティクスを用いても効率が向上しない場面
- 元オブジェクトが左辺値である
ごく一部の例外を除き（Item 25などを参照），ムーブ元となれるのは右辺値のみである．

## おわりに
本項目のタイトルは「ムーブ演算は存在しない，コスト安でもない，使用もされないと **想定する**」だ．
その理由は，テンプレートを記述する場合など一般的なコードの多くにおいて，使用する型のすべてを熟知している訳ではないためだ．
このような状況では，C++98（ムーブセマンティクス導入前）がそうだったように，オブジェクトのコピーについては保守的な立場をとらざるを得ない．
また，コードが「不安定 (unstable)」になる場面でもある．
すなわち，使用する型の性質が比較的頻繁に変更される傾向を持つ状況だ．

しかし，使用する型を熟知しており，その性質が変更されないと分かっている場合も多くある（コスト高ではないムーブ演算に対応しているか否かなど）．
この場合，本項目の想定は無用．
使用する型がコスト安なムーブ演算を備えていて，かつ，そのムーブ演算が実行される場面でそのオブジェクトを使用しているならば，コピー演算がコスト安なムーブ演算で置き換えられると想定しても安全だ．

## Things to remember
- ムーブ演算は存在しない，コスト安でもない，使用もされないと想定する．
- 既知の型，ムーブ対応済みの型を使用する場合は，上記想定は不要である．
