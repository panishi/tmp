---
marp: true
theme: "night"
transition: "slide"
slideNumber: true
title: "Chapter02"
---
<!-- theme: gaia -->
<!-- size: 16:9 -->
<!-- page_number: true -->
<!-- paginate: true -->

# プログラミングRust
2.2　簡単な関数
2.3　ユニットテストの記述と実行
2.4　コマンドライン引数の処理
2.5　簡単なWebサーバ

2020/07/10

---
## 2.2　簡単な関数

- ユークリッドのアルゴリズムを実装してみよう
```rust
fn gcd(mut n: u64, mut m: u64) -> u64 {
    assert!(n != 0 && m != 0);
    while m != 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    n
}
```

---
### 文法の簡単な解説1
- `fn` キーワード（「fun（ファン）」と発音）で関数を定義
    - `u64` とは64ビット整数
    - `->` トークンの後ろが関数の戻り型
    - インデントはスペース4つが標準
- デフォルトで `const`
    - `mut` キーワードで変更可能（mutable（可変）の省略で「mute（ミュート）」と発音）

---
### 文法の簡単な解説2
- `assert!` マクロ
    - Rustではコンパイル方法によらず常にチェック
    - `debug_assert!` マクロはデバッグ専用
- 条件式には括弧不要
- `let` で型推論
- `return` と明示的に書かなくて良い
    - 関数のボディがセミコロンなしの式で終わっている場合，その式が関数の返り値
    - early returnする場合のみ明示的に `return` を書く

---
## 2.3　ユニットテストの記述と実行
- Rustでは，テスト機構が言語に組み込まれている :+1:
```rust
#[test]
fn test_gcd() {
    assert_eq!(gcd(14, 15), 1);
    assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                   3 * 7 * 11 * 13 * 19),
               3 * 11);
}
```
- `#[test]` は，`test_gcd` がテスト関数であることを示している
    - 実演タイム

---
## 2.4　コマンドライン引数の処理
- コマンドラインからの引数取得を試みる
    - `main` 関数はコード参照
- それなりに長いが，以下では部分的に文法を解説していく

---
### 文法の簡単な解説3
- トレイト
    - `use` 宣言で取り込む
    - トレイトは，型が実装することのできるメソッドの集合
- `Write` トレイト
    - 整形した文字列をストリームに書き出す `write_fmt` メソッドを持つ（ここでは `writeln!` マクロを使っている）
- `FromStr` トレイト
    - 文字列を解析してその型に変換する `from_str` メソッドを持つ
    - `u64` 型は `FromStr` を実装している

---
### 文法の簡単な解説4
- `main` 関数は戻り型がない
- ベクタの初期化
    - `Vec<u64>` と明示的に書く必要はない
    - `u64` を `push` していることから，Rustはベクタの型を推論可能
    - `gcd` 関数のI/Fからも推論可能
- `std::env::args` はイテレータを返す
    - `skip` メソッドで最初の値（プログラム名）を省く

---
### 文法の簡単な解説5
- `u64::from_str` で符号なし64ビット整数としてパース
    - パースが成功したかどうかを示す `Result` 値を返す
    - `Ok(v)` と `Error(e)`
    - 全てのエラーは `Result` かパニックで処理される（7章参照）
    - `Result` の `expect` メソッドでパースの成功を確認
- 空の場合はGCDが定義出来ないので確認
    - `std::io::stderr()` でエラーメッセージを書き出し
    - `.unwrap()` は，エラーメッセージの出力の成功をチェックする無愛想な書き方

---
### 文法の簡単な解説6
- `d` には `mut` をつけてループで価を代入可とする
- 所有権について
    - `&` 演算子は，ベクタの2番目以降の要素への参照を借用
    - `*` 演算子は，参照解決を行う
    - `main` 関数の最後でスコープから外れると，ベクタは自動的に解放される
- `println!` マクロで出力
- `cargo run` で実行
    - 実演タイム

---
## 2.5　簡単なWebサーバ
- crates.io (https://crates.io) で無償のライブラリ群が公開されている
    - `cargo` コマンドでcrates.ioのパッケージを自分のコードで簡単に利用可能
    - Rustのパッケージは，クレート (crate) と呼ばれる（crateは輸送用の箱，Cargoは貨物を意味する）
- Webフレームワークである `iron`，HTTPサーバ `hyper` 等のクレートを用いて簡単なWebサーバを作ってみる
    - ユーザに2つの数字を入力させ，GCDを計算する

---
### `iron-gcd` の作成
- `Cargo` を用いて，`iron-gcd` という名前の新しいパッケージを作る
- 新しいプロジェクトの `Cargo.toml` ファイルを編集して利用したいパッケージを列挙する
    - `[dependencies]` セクションの各行に，crates.ioにある利用したいクレートの名前とバージョンを記述する
    - 直接利用するパッケージのみ記述すれば，パッケージが利用するパッケージについては `Cargo` が管理する

---
### 簡単なWebサーバの作成1
- ユーザに数字の入力を求めるだけのページを作る
    - iron-gcd/src/main.rsを参照
- 冒頭の2つの `extern crate` ディレクティブ
    - `Cargo.toml` に書いたクレート `iron` と `mime` をプログラムから利用するためのもの
    - `#[macro_use]` 属性は，このクレートでエクスポートされているマクロを使うため
- クレートの公開されている機能を取り込むために `use` 宣言を書く

---
### 簡単なWebサーバの作成2
- `main`関数の仕事は単純
    - サーバに接続する方法が書かれたメッセージを出力
    - `Iron::new` を呼び出してサーバを作成
    - ローカルマシンのTCPの3000番ポートを待ち受けるように設定
- `get_form` 関数は，処理すべきHTTPリクエストを表す `Request` 値への参照を引数として取る
    - 後で使用するがまだ使っておらず，警告を避けるため仮引数の名前を`_` で始める

---
### 簡単なWebサーバの作成3
- 関数のボディ部で `Response` を作成
    - `set_mut` メソッドは，引数の型で `response` のどの部分に値を設定するかを決定
        - `status::Ok`：HTTPステータス
        - メディアタイプ：`Content-Type` ヘッダ
        - 文字列：レスポンスのボディ部
- \を記述するためにRustの「生文字列 (raw string)」構文 (`r`) を用いている
- 関数の返り値の型 `IronResult<Response>` は，`Result` の一種

---
### ページ表示の改良
- 「Compute GCD」をクリックしても何も起こらない
    - このサーバではどのURL に行っても同じページが表示される
    - `Router` 型を使って，パスごとに別のハンドラを割り当てる
- `main` 関数を修正
    - `Router` を作り，2つのパスにそれぞれのハンドラ関数を設定
    - `Router` を `Iron::new` にリクエストハンドラとして渡し，URLパスによってハンドラ関数を決定するWebサーバができる

---
### `match` 式1
- `post_gcd` 関数を定義する
- 関数の大部分は一連の `match` 式で構成されている
    - HaskellやOCamlでは馴染みのあるもの
    - `match` 式を使うと，`Result` の値がどちらなのかをチェックした上で，内部の値を取り出せる
    ```rust
    match res {
        Ok(success) => { ... },
        Err(error) => { ... }
    }
    ```

---
### `match` 式2
- `Result` は `Ok` か `Err` かを先にチェックしないと中の値にアクセスできない
    - CとC++ではエラーコードやヌルポインタをチェックし忘れることがよくあるが，Rustではそのようなミスをコンパイル時に検出可能
- Rustでは，`Result` のような「それぞれ値を保持する複数の異型を持つ型」を自分で定義することが可能
    - Rust ではこのような型を（**列挙型**） **enum** と呼ぶ（10章参照）

---
### `post_gcd` の構造1
- `request.get_ref::<UrlEncodedBody>()` を呼んで，リクエストのボディをパース，クエリパラメータ名と値の配列のテーブルに変換
    - パースが失敗したらエラーをクライアントに報告
    - メソッド呼び出しの `::<UrlEncodedBody>` は **型パラメータ** (type parameter）
    - `UrlEncodedBody` は，ボディ部をURLエンコードされたクエリ文字列としてパースすることを意味する

---
### `post_gcd` の構造2
- パースされたテーブルから `"n"` というクエリパラメータを取得
    - クエリパラメータでは同じ名前を何度も使うことができるため，文字列1つではなく，文字列のベクタとなっている
- 文字列のベクタの要素を1つずつパース
    - 1つでもパースに失敗したら適切なエラーページを返す
- 最後に，複数の数のGCDを計算，結果を書いたレスポンスを作る
    - `format!` マクロは，`writeln!` マクロや `println!` マクロと同じ文字列テンプレートを用いるマクロ
    - ストリームにテキストを書き出さず，文字列を返す

---
### ブラウザ上でのGCD計算の実行
- `gcd` 関数を書き込んだら，リビルドして再実行する
    - 以前実行したサーバが動作していたら，停止してからビルドする
- http://localhost:3000 にアクセスし，何らかの値を入力，「Compute GCD」ボタンを押せば，今度は結果が表示される
    - 実演タイム
